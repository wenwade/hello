<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust By Practice( Rust 练习实践 )</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="Learning Rust By Practice, narrowing the gap between beginner and skilled-dev with challenging examples, exercises and projects.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/style1.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="why-exercise.html"><strong aria-hidden="true">1.</strong> 关于 practice.rs</a></li><li class="chapter-item expanded "><a href="elegant-code-base.html"><strong aria-hidden="true">2.</strong> 值得学习的小型项目</a></li><li class="chapter-item expanded "><a href="variables.html"><strong aria-hidden="true">3.</strong> 变量绑定与解构</a></li><li class="chapter-item expanded "><a href="basic-types/intro.html"><strong aria-hidden="true">4.</strong> 基本类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="basic-types/numbers.html"><strong aria-hidden="true">4.1.</strong> 数值类型</a></li><li class="chapter-item "><a href="basic-types/char-bool-unit.html"><strong aria-hidden="true">4.2.</strong> 字符、布尔、单元类型</a></li><li class="chapter-item "><a href="basic-types/statements-expressions.html"><strong aria-hidden="true">4.3.</strong> 语句与表达式</a></li><li class="chapter-item "><a href="basic-types/functions.html"><strong aria-hidden="true">4.4.</strong> 函数</a></li></ol></li><li class="chapter-item expanded "><a href="ownership/intro.html"><strong aria-hidden="true">5.</strong> 所有权和借用</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ownership/ownership.html"><strong aria-hidden="true">5.1.</strong> 所有权</a></li><li class="chapter-item "><a href="ownership/borrowing.html"><strong aria-hidden="true">5.2.</strong> 引用和借用</a></li></ol></li><li class="chapter-item expanded "><a href="compound-types/intro.html"><strong aria-hidden="true">6.</strong> 复合类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="compound-types/string.html"><strong aria-hidden="true">6.1.</strong> 字符串</a></li><li class="chapter-item "><a href="compound-types/array.html"><strong aria-hidden="true">6.2.</strong> 数组</a></li><li class="chapter-item "><a href="compound-types/slice.html"><strong aria-hidden="true">6.3.</strong> 切片</a></li><li class="chapter-item "><a href="compound-types/tuple.html"><strong aria-hidden="true">6.4.</strong> 元组</a></li><li class="chapter-item "><a href="compound-types/struct.html"><strong aria-hidden="true">6.5.</strong> 结构体</a></li><li class="chapter-item "><a href="compound-types/enum.html"><strong aria-hidden="true">6.6.</strong> 枚举</a></li></ol></li><li class="chapter-item expanded "><a href="flow-control.html"><strong aria-hidden="true">7.</strong> 流程控制</a></li><li class="chapter-item expanded "><a href="pattern-match/intro.html"><strong aria-hidden="true">8.</strong> 模式匹配</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="pattern-match/match-iflet.html"><strong aria-hidden="true">8.1.</strong> match, matches! 和 if let</a></li><li class="chapter-item "><a href="pattern-match/patterns.html"><strong aria-hidden="true">8.2.</strong> 模式</a></li></ol></li><li class="chapter-item expanded "><a href="method.html"><strong aria-hidden="true">9.</strong> 方法和关联函数</a></li><li class="chapter-item expanded "><a href="generics-traits/intro.html"><strong aria-hidden="true">10.</strong> 泛型和特征</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="generics-traits/generics.html"><strong aria-hidden="true">10.1.</strong> 泛型</a></li><li class="chapter-item "><a href="generics-traits/const-generics.html"><strong aria-hidden="true">10.2.</strong> Const 泛型</a></li><li class="chapter-item "><a href="generics-traits/traits.html"><strong aria-hidden="true">10.3.</strong> 特征 Traits</a></li><li class="chapter-item "><a href="generics-traits/trait-object.html"><strong aria-hidden="true">10.4.</strong> 特征对象</a></li><li class="chapter-item "><a href="generics-traits/advanced-traits.html"><strong aria-hidden="true">10.5.</strong> 进一步深入特征</a></li></ol></li><li class="chapter-item expanded "><a href="collections/intro.html"><strong aria-hidden="true">11.</strong> 集合类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="collections/string.html"><strong aria-hidden="true">11.1.</strong> 动态字符串 String</a></li><li class="chapter-item "><a href="collections/vector.html"><strong aria-hidden="true">11.2.</strong> 动态数组 Vector</a></li><li class="chapter-item "><a href="collections/hashmap.html"><strong aria-hidden="true">11.3.</strong> KV 存储 HashMap</a></li></ol></li><li class="chapter-item expanded "><a href="type-conversions/intro.html"><strong aria-hidden="true">12.</strong> 类型转换</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="type-conversions/as.html"><strong aria-hidden="true">12.1.</strong> as</a></li><li class="chapter-item "><a href="type-conversions/from-into.html"><strong aria-hidden="true">12.2.</strong> From/Into</a></li><li class="chapter-item "><a href="type-conversions/others.html"><strong aria-hidden="true">12.3.</strong> 其它转换</a></li></ol></li><li class="chapter-item expanded "><a href="result-panic/intro.html"><strong aria-hidden="true">13.</strong> 返回值和 panic!</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="result-panic/panic.html"><strong aria-hidden="true">13.1.</strong> panic! 深入剖析</a></li><li class="chapter-item "><a href="result-panic/result.html"><strong aria-hidden="true">13.2.</strong> 返回值result 和 ?</a></li></ol></li><li class="chapter-item expanded "><a href="crate-module/intro.html"><strong aria-hidden="true">14.</strong> 包和模块</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="crate-module/crate.html"><strong aria-hidden="true">14.1.</strong> 包 Crate</a></li><li class="chapter-item "><a href="crate-module/module.html"><strong aria-hidden="true">14.2.</strong> 模块 Module</a></li><li class="chapter-item "><a href="crate-module/use-pub.html"><strong aria-hidden="true">14.3.</strong> 使用use引入模块及受限可见性</a></li></ol></li><li class="chapter-item expanded "><a href="comments-docs.html"><strong aria-hidden="true">15.</strong> 注释和文档</a></li><li class="chapter-item expanded "><a href="formatted-output.html"><strong aria-hidden="true">16.</strong> 格式化输出</a></li><li class="chapter-item expanded "><a href="lifetime/intro.html"><strong aria-hidden="true">17.</strong> 生命周期</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="lifetime/basic.html"><strong aria-hidden="true">17.1.</strong> 生命周期基础</a></li><li class="chapter-item "><a href="lifetime/static.html"><strong aria-hidden="true">17.2.</strong> &'static 和 T: 'static</a></li><li class="chapter-item "><a href="lifetime/advance.html"><strong aria-hidden="true">17.3.</strong> 深入生命周期</a></li></ol></li><li class="chapter-item expanded "><a href="functional-programing/intro.html"><strong aria-hidden="true">18.</strong> 函数式编程: 闭包、迭代器 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="functional-programing/closure.html"><strong aria-hidden="true">18.1.</strong> 闭包 Closure</a></li><li class="chapter-item "><a href="functional-programing/iterator.html"><strong aria-hidden="true">18.2.</strong> 迭代器 Iterator</a></li></ol></li><li class="chapter-item expanded "><a href="newtype-sized.html"><strong aria-hidden="true">19.</strong> newtype 和 Sized todo</a></li><li class="chapter-item expanded "><a href="smart-pointers/intro.html"><strong aria-hidden="true">20.</strong> 智能指针 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="smart-pointers/box.html"><strong aria-hidden="true">20.1.</strong> Box</a></li><li class="chapter-item "><a href="smart-pointers/deref.html"><strong aria-hidden="true">20.2.</strong> Deref</a></li><li class="chapter-item "><a href="smart-pointers/drop.html"><strong aria-hidden="true">20.3.</strong> Drop</a></li><li class="chapter-item "><a href="smart-pointers/rc-arc.html"><strong aria-hidden="true">20.4.</strong> Rc and Arc</a></li><li class="chapter-item "><a href="smart-pointers/cell-refcell.html"><strong aria-hidden="true">20.5.</strong> Cell and RefCell</a></li></ol></li><li class="chapter-item expanded "><a href="weak.html"><strong aria-hidden="true">21.</strong> Weak 和循环引用todo</a></li><li class="chapter-item expanded "><a href="self-referential.html"><strong aria-hidden="true">22.</strong> 自引用 todo</a></li><li class="chapter-item expanded "><a href="threads/intro.html"><strong aria-hidden="true">23.</strong> 多线程 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="threads/basic-using.html"><strong aria-hidden="true">23.1.</strong> 多线程基础</a></li><li class="chapter-item "><a href="threads/message-passing.html"><strong aria-hidden="true">23.2.</strong> 消息传递</a></li><li class="chapter-item "><a href="threads/sync.html"><strong aria-hidden="true">23.3.</strong> 线程同步：锁、Condvar和信号量</a></li><li class="chapter-item "><a href="threads/atomic.html"><strong aria-hidden="true">23.4.</strong> 线程同步：Atomic</a></li><li class="chapter-item "><a href="threads/send-sync.html"><strong aria-hidden="true">23.5.</strong> Send 和 Sync</a></li></ol></li><li class="chapter-item expanded "><a href="global-variables.html"><strong aria-hidden="true">24.</strong> 全局变量 todo</a></li><li class="chapter-item expanded "><a href="errors.html"><strong aria-hidden="true">25.</strong> 错误处理 todo</a></li><li class="chapter-item expanded "><a href="unsafe/intro.html"><strong aria-hidden="true">26.</strong> Unsafe doing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="unsafe/inline-asm.html"><strong aria-hidden="true">26.1.</strong> 内联汇编</a></li></ol></li><li class="chapter-item expanded "><a href="macro.html"><strong aria-hidden="true">27.</strong> macro 宏 todo</a></li><li class="chapter-item expanded "><a href="tests/intro.html"><strong aria-hidden="true">28.</strong> 测试 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tests/write-tests.html"><strong aria-hidden="true">28.1.</strong> 编写测试及控制执行</a></li><li class="chapter-item "><a href="tests/benchmark.html"><strong aria-hidden="true">28.2.</strong> 基准性能测试 Benchmark</a></li><li class="chapter-item "><a href="tests/unit-integration.html"><strong aria-hidden="true">28.3.</strong> 单元测试及集成测试</a></li><li class="chapter-item "><a href="tests/assertions.html"><strong aria-hidden="true">28.4.</strong> 断言 Assertions</a></li></ol></li><li class="chapter-item expanded "><a href="async/intro.html"><strong aria-hidden="true">29.</strong> Async/Await 异步编程 todo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="async/async-await.html"><strong aria-hidden="true">29.1.</strong> async 和 await!</a></li><li class="chapter-item "><a href="async/future.html"><strong aria-hidden="true">29.2.</strong> Future</a></li><li class="chapter-item "><a href="async/pin-unpin.html"><strong aria-hidden="true">29.3.</strong> Pin 和 Unpin</a></li><li class="chapter-item "><a href="async/stream.html"><strong aria-hidden="true">29.4.</strong> Stream 流处理</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>
        
        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust By Practice( Rust 练习实践 )</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/sunface/rust-by-practice" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <!-- Page table of contents -->
                    <div class="sidetoc"><nav class="pagetoc"></nav></div>
                    <main>
                        <h1 align="center">Rust语言实战</h1>
<div align="center">
    <img height="150" src="https://github.com/sunface/rust-by-practice/blob/master/en/assets/logo.png?raw=true">
</div>
<p align="center">通过有挑战性的示例、练习题、实践项目来提升 Rust 水平，建立从入门学习到上手实战的直通桥梁</p>
<div align="center">
<p><a href="https://github.com/sunface/rust-by-practice/stargazers"><img src="https://img.shields.io/github/stars/sunface/rust-by-practice?style=flat" alt="Stars Count" /></a> <a href="https://github.com/naaive/orange/network/members"><img src="https://img.shields.io/github/forks/sunface/rust-by-practice.svg?style=flat" alt="Forks Count" /></a>
<a href="https://github.com/sunface/rust-by-practice/blob/master/LICENSE"><img src="https://img.shields.io/badge/license-mit-green?style=flat" alt="LICENSE" /></a></p>
</div>
<p><em>Rust语言实战</em> 的目标是通过大量的实战练习帮助大家更好的学习和上手使用 Rust 语言。书中的练习题非常易于使用：你所需的就是在线完成练习，并让它通过编译。</p>
<h2 id="在线阅读"><a class="header" href="#在线阅读">在线阅读</a></h2>
<ul>
<li><a href="https://zh.practice.rs">https://zh.practice.rs</a></li>
</ul>
<h2 id="本地运行"><a class="header" href="#本地运行">本地运行</a></h2>
<p>我们使用 <a href="https://rust-lang.github.io/mdBook/">mdbook</a> 构建在线练习题，你也可以下载到本地运行：</p>
<pre><code class="language-shell">$ git clone git@github.com:sunface/rust-by-practice.git
$ cargo install mdbook
$ cd rust-by-practice &amp;&amp; mdbook serve zh-CN/
</code></pre>
<p>在本地win 10或者linux服务器上运行时，应当使用 -n 参数指定mdbook服务所监听的IP地址（-p 参数指定服务监听的端口，不指定则为默认的3000），以win 10本地运行为例：</p>
<pre><code class="language-shell">$ mdbook serve -p 8888 -n 127.0.0.1 zh-CN/
</code></pre>
<h2 id="特性"><a class="header" href="#特性">特性</a></h2>
<p>部分示例和习题借鉴了 <a href="https://github.com/rust-lang/rust-by-example">Rust By Example</a>, 书中的示例真的非常棒！</p>
<p>尽管它们非常优秀，我们这本书也有自己的秘密武器 :)</p>
<ul>
<li>
<p>每个章节分为三个可选部分：示例、练习和实践项目</p>
</li>
<li>
<p>除了示例外，我们还有大量的高质量练习题，你可以在线阅读、修改和编译它们</p>
</li>
<li>
<p>覆盖了 Rust 语言的几乎所有方面：基础语言特性、高级语言特性、async/await 异步编程、多线程、并发原语、性能优化、工具链使用、标准库、数据结构和算法等</p>
</li>
<li>
<p>每一道练习题都提供了解答</p>
</li>
<li>
<p>整体难度相对更高，更加贴近于实战难度: 简单 🌟 , 中等 🌟🌟 , 困难 🌟🌟🌟  , 地狱 🌟🌟🌟🌟</p>
</li>
</ul>
<p><strong>总之，我们想做的就是解决入门学习后，不知道该如何运用的问题，毕竟对于 Rust 来说，从学习到实战，中间还隔着数个 Go语言 的难度</strong></p>
<h2 id="关于我们"><a class="header" href="#关于我们">关于我们</a></h2>
<p><em>Rust语言实战</em> 由 Rust 编程学院倾情打造。</p>
<p>同时我们还提供了一本目前最好也是最用心的开源 Rust 书籍 - <a href="https://github.com/sunface/rust-course">Rust语言圣经</a>， 适合从入门到精通所有阶段的学习，欢迎大家阅读使用。</p>
<p>对我们来说，来自读者大大的肯定比什么都重要，因此一个 <a href="https://github.com/sunface/rust-by-practice">Github star</a> 要比一杯咖啡更让我们开心，而且现在它在跳楼打折，无需 998 ， 仅需 0 元钱 :)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="值得学习的小型项目"><a class="header" href="#值得学习的小型项目">值得学习的小型项目</a></h1>
<p>在国内外的各大 Rust 论坛上，以下问题非常常见:</p>
<ul>
<li>作为 Rust 新手，有哪些项目值得推荐学习?</li>
<li>求推荐代码优雅的小型项目</li>
<li>有哪些值得推荐的简单、易读的项目</li>
</ul>
<p>这些问题的答案往往只有一个，那就是实践：做一些优秀的练习题，然后阅读一些小而美的 Rust 项目。</p>
<p>这个恰恰跟本书的目标吻合，因此，我们决定收集一些优秀的资源，并在 <em>Rust语言实战</em> 中呈现给大家。</p>
<h3 id="1-ripgrep"><a class="header" href="#1-ripgrep">1. Ripgrep</a></h3>
<p>以上的问题通常都会伴随着 <a href="https://github.com/BurntSushi/ripgrep"><code>ripgrep</code></a> 的推荐, 虽然我不认为它是一个小型项目，但是依然非常推荐大家学习，当然，首先你得做好深挖的准备和耐心。</p>
<h3 id="2-教程构建一个文本编辑器"><a class="header" href="#2-教程构建一个文本编辑器">2. 教程：构建一个文本编辑器</a></h3>
<p>该教程 <a href="https://www.flenker.blog/hecto/"><code>https://www.flenker.blog/hecto/</code></a> 将带领我们从零开始构建一个文本编辑器.</p>
<h3 id="3-ncspot"><a class="header" href="#3-ncspot">3. Ncspot</a></h3>
<p><a href="https://github.com/hrkfdn/ncspot">Ncspot</a> 是一个终端访问的 Spotify 客户端，小巧、简单、良好的代码组织以及异步编程，值得学习.</p>
<h3 id="4-命令行-rust"><a class="header" href="#4-命令行-rust">4. 命令行 Rust</a></h3>
<p><a href="https://github.com/kyclark/command-line-rust">这个项目</a> 是书本 <code>Command-Line Rust(O'Reily)</code> 的配套项目，可以帮助大家理解该如何更好的编写命令行程序，例如 <code>head</code>, <code>cat</code>, <code>ls</code>。</p>
<h3 id="5-在-png-中隐藏你的秘密"><a class="header" href="#5-在-png-中隐藏你的秘密">5. 在 PNG 中隐藏你的秘密</a></h3>
<p><a href="https://jrdngr.github.io/pngme_book/">这本书</a> 将带领大家编写一个命令行程序，功能是在 PNG 文件中隐藏一些秘密信息，首要目标是让我们熟悉 Rust 代码。</p>
<h3 id="6-使用-rust-写一个小型-os"><a class="header" href="#6-使用-rust-写一个小型-os">6. 使用 Rust 写一个小型 OS</a></h3>
<p><a href="https://os.phil-opp.com">这个博客系列</a> 会带领大家使用 Rust 语言创建一个小型的操作系统。其中每一篇文章都是一个小的教程并包含完整的代码。</p>
<p>你也可以在<a href="https://github.com/phil-opp/blog_os">以下地址</a>找到完整的源代码。</p>
<h3 id="7-codecraftersio-写一个你自己的-git-dockersqlite-或-redis"><a class="header" href="#7-codecraftersio-写一个你自己的-git-dockersqlite-或-redis">7. CodeCrafters.io: 写一个你自己的 Git， Docker，SQLite 或 Redis</a></h3>
<p>在 <a href="https://codecrafters.io/for/rust">CodeCrafters</a> 上，你可以从头开始重新创建您最喜欢的开发人员工具。这是一种掌握 Rust 的实践、最低限度指导的方法，同时欣赏我们每天使用的流行技术的内部结构和文档。</p>
<h3 id="8-mini-redis"><a class="header" href="#8-mini-redis">8. mini-redis</a></h3>
<p><a href="https://github.com/tokio-rs/mini-redis">mini-redis</a> 是一个不完整的 Redis 客户端、服务器实现，由 tokio 官方出品，代码质量非常高，而且有详细的注释，非常适合学习 Rust 和异步编程。</p>
<h3 id="9-使用-rust-写一个解析器"><a class="header" href="#9-使用-rust-写一个解析器">9. 使用 Rust 写一个解析器</a></h3>
<p><a href="https://rust-hosted-langs.github.io/book/">这本开源书</a> 是一个使用 Rust 语言实现编译型语言的教程。</p>
<h3 id="10-rust编写推箱子游戏教程"><a class="header" href="#10-rust编写推箱子游戏教程">10. Rust编写推箱子游戏教程</a></h3>
<p><a href="https://sokoban.iolivia.me/zh_cn/c01-00-intro">sokoban</a> 是一个使用 Rust 语言实现 sokoban 游戏的教程。虽然社区已停止活跃（ Initial Commits on Sep 3, 2019，GitHub 仓库最后一条 commit 是 last year ），但是项目是完善的 release v0.1.0，拿来练手是个不错的选择。</p>
<p><strong>To be continued...</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="变量绑定与解构"><a class="header" href="#变量绑定与解构">变量绑定与解构</a></h1>
<h3 id="绑定和可变性"><a class="header" href="#绑定和可变性">绑定和可变性</a></h3>
<ol>
<li>🌟 变量只有在初始化后才能被使用</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 修复下面代码的错误并尽可能少的修改
fn main() {
    let x: i32; // 未初始化，但被使用
    let y: i32; // 未初始化，也未被使用
    println!("x is equal to {}", x); 
}</code></pre></pre>
<ol start="2">
<li>🌟🌟 可以使用 <code>mut</code> 将变量标记为可变</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 完形填空，让代码编译
fn main() {
    let __ = 1;
    __ += 2; 
    
    println!("x = {}", x); 
}</code></pre></pre>
<h3 id="变量作用域"><a class="header" href="#变量作用域">变量作用域</a></h3>
<ol start="3">
<li>🌟 作用域是一个变量在程序中能够保持合法的范围</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 修复下面代码的错误并使用尽可能少的改变
fn main() {
    let x: i32 = 10;
    {
        let y: i32 = 5;
        println!("x 的值是 {}, y 的值是 {}", x, y);
    }
    println!("x 的值是 {}, y 的值是 {}", x, y); 
}</code></pre></pre>
<ol start="4">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 修复错误
fn main() {
    println!("{}, world", x); 
}

fn define_x() {
    let x = "hello";
}</code></pre></pre>
<h3 id="变量遮蔽-shadowing-"><a class="header" href="#变量遮蔽-shadowing-">变量遮蔽( Shadowing )</a></h3>
<ol start="5">
<li>🌟🌟 若后面的变量声明的名称和之前的变量相同，则我们说：第一个变量被第二个同名变量遮蔽了( shadowing )</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 只允许修改 `assert_eq!` 来让 `println!` 工作(在终端输出 `42`)
fn main() {
    let x: i32 = 5;
    {
        let x = 12;
        assert_eq!(x, 5);
    }

    assert_eq!(x, 12);

    let x = 42;
    println!("{}", x); // 输出 "42".
}</code></pre></pre>
<ol start="6">
<li>🌟🌟 修改一行代码以通过编译</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let mut x: i32 = 1;
    x = 7;
    // 遮蔽且再次绑定
    let x = x; 
    x += 3;


    let y = 4;
    // 遮蔽
    let y = "I can also be bound to text!"; 
}</code></pre></pre>
<h3 id="未使用的变量"><a class="header" href="#未使用的变量">未使用的变量</a></h3>
<ol start="7">
<li>使用以下方法来修复编译器输出的 warning :</li>
</ol>
<ul>
<li>🌟  一种方法</li>
<li>🌟🌟  两种方法</li>
</ul>
<blockquote>
<p>注意: 你可以使用两种方法解决，但是它们没有一种是移除 <code>let x = 1</code> 所在的代码行</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let x = 1; 
}

// compiler warning: unused variable: `x`</code></pre></pre>
<h3 id="变量解构"><a class="header" href="#变量解构">变量解构</a></h3>
<ol start="8">
<li>🌟🌟 我们可以将 <code>let</code> 跟一个模式一起使用来解构一个元组，最终将它解构为多个独立的变量</li>
</ol>
<blockquote>
<p>提示: 可以使用变量遮蔽或可变性</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 修复下面代码的错误并尽可能少的修改
fn main() {
    let (x, y) = (1, 2);
    x += 2;

    assert_eq!(x, 3);
    assert_eq!(y, 2);
}</code></pre></pre>
<h3 id="解构式赋值"><a class="header" href="#解构式赋值">解构式赋值</a></h3>
<p>该功能于 Rust 1.59 版本引入：你可以在赋值语句的左式中使用元组、切片或结构体进行匹配赋值。</p>
<ol start="9">
<li>🌟🌟</li>
</ol>
<blockquote>
<p>Note: 解构式赋值只能在 Rust 1.59 或者更高版本中使用</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let (x, y);
    (x,..) = (3, 4);
    [.., y] = [1, 2];
    // 填空，让代码工作
    assert_eq!([x,y], __);
} </code></pre></pre>
<blockquote>
<p><a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/variables.md">答案</a> 在 solutions 下面</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基本类型"><a class="header" href="#基本类型">基本类型</a></h1>
<p>学习资料:</p>
<ul>
<li>English: <a href="https://doc.rust-lang.org/book/ch03-02-data-types.html">Rust Book 3.2 and 3.3</a></li>
<li>简体中文: <a href="https://course.rs/basic/base-type/index.html">Rust语言圣经 - 基本类型</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数值类型"><a class="header" href="#数值类型">数值类型</a></h1>
<h3 id="整数"><a class="header" href="#整数">整数</a></h3>
<ol>
<li>🌟</li>
</ol>
<blockquote>
<p>Tips: 如果我们没有显式的给予变量一个类型，那编译器会自动帮我们推导一个类型</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 移除某个部分让代码工作
fn main() {
    let x: i32 = 5;
    let mut y: u32 = 5;

    y = x;
    
    let z = 10; // 这里 z 的类型是? 
}</code></pre></pre>
<ol start="2">
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 填空
fn main() {
    let v: u16 = 38_u8 as __;
}</code></pre></pre>
<ol start="3">
<li>🌟🌟🌟</li>
</ol>
<blockquote>
<p>Tips: 如果我们没有显式的给予变量一个类型，那编译器会自动帮我们推导一个类型</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 修改 `assert_eq!` 让代码工作
fn main() {
    let x = 5;
    assert_eq!("u32".to_string(), type_of(&amp;x));
}

// 以下函数可以获取传入参数的类型，并返回类型的字符串形式，例如  "i8", "u8", "i32", "u32"
fn type_of&lt;T&gt;(_: &amp;T) -&gt; String {
    format!("{}", std::any::type_name::&lt;T&gt;())
}</code></pre></pre>
<ol start="4">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 填空，让代码工作
fn main() {
    assert_eq!(i8::MAX, __); 
    assert_eq!(u8::MAX, __); 
}</code></pre></pre>
<ol start="5">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 解决代码中的错误和 `panic`
fn main() {
   let v1 = 251_u8 + 8;
   let v2 = i8::checked_add(251, 8).unwrap();
   println!("{},{}",v1,v2);
}</code></pre></pre>
<ol start="6">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 修改 `assert!` 让代码工作
fn main() {
    let v = 1_024 + 0xff + 0o77 + 0b1111_1111;
    assert!(v == 1579);
}</code></pre></pre>
<h3 id="浮点数"><a class="header" href="#浮点数">浮点数</a></h3>
<ol start="7">
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 将 ? 替换成你的答案
fn main() {
    let x = 1_000.000_1; // ?
    let y: f32 = 0.12; // f32
    let z = 0.01_f64; // f64
}</code></pre></pre>
<ol start="8">
<li>🌟🌟 使用两种方法来让下面代码工作</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    assert!(0.1+0.2==0.3);
}</code></pre></pre>
<h3 id="序列range"><a class="header" href="#序列range">序列Range</a></h3>
<ol start="9">
<li>🌟🌟 两个目标: 1. 修改 <code>assert!</code> 让它工作 2. 让 <code>println!</code> 输出: 97 - 122</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut sum = 0;
    for i in -3..2 {
        sum += i
    }

    assert!(sum == -3);

    for c in 'a'..='z' {
        println!("{}",c);
    }
}</code></pre></pre>
<ol start="10">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 填空
use std::ops::{Range, RangeInclusive};
fn main() {
    assert_eq!((1..__), Range{ start: 1, end: 5 });
    assert_eq!((1..__), RangeInclusive::new(1, 5));
}</code></pre></pre>
<h3 id="计算"><a class="header" href="#计算">计算</a></h3>
<ol start="11">
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 填空，并解决错误
fn main() {
    // 整数加法
    assert!(1u32 + 2 == __);

    // 整数减法
    assert!(1i32 - 2 == __);
    assert!(1u8 - 2 == -1);
    
    assert!(3 * 50 == __);

    assert!(9.6 / 3.2 == 3.0); // error ! 修改它让代码工作

    assert!(24 % 5 == __);
    
    // 逻辑与或非操作
    assert!(true &amp;&amp; false == __);
    assert!(true || false == __);
    assert!(!true == __);

    // 位操作
    println!("0011 AND 0101 is {:04b}", 0b0011u32 &amp; 0b0101);
    println!("0011 OR 0101 is {:04b}", 0b0011u32 | 0b0101);
    println!("0011 XOR 0101 is {:04b}", 0b0011u32 ^ 0b0101);
    println!("1 &lt;&lt; 5 is {}", 1u32 &lt;&lt; 5);
    println!("0x80 &gt;&gt; 2 is 0x{:x}", 0x80u32 &gt;&gt; 2);
}</code></pre></pre>
<blockquote>
<p>你可以在<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/basic-types/numbers.md">这里</a>找到答案(在 solutions 路径下)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字符布尔单元类型"><a class="header" href="#字符布尔单元类型">字符、布尔、单元类型</a></h1>
<h3 id="字符"><a class="header" href="#字符">字符</a></h3>
<ol>
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 修改2处 `assert_eq!` 让代码工作

use std::mem::size_of_val;
fn main() {
    let c1 = 'a';
    assert_eq!(size_of_val(&amp;c1),1); 

    let c2 = '中';
    assert_eq!(size_of_val(&amp;c2),3); 

    println!("Success!")
} </code></pre></pre>
<ol start="2">
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 修改一行让代码正常打印
fn main() {
    let c1 = "中";
    print_char(c1);
} 

fn print_char(c : char) {
    println!("{}", c);
}</code></pre></pre>
<h3 id="布尔"><a class="header" href="#布尔">布尔</a></h3>
<ol start="3">
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 使成功打印
fn main() {
    let _f: bool = false;

    let t = true;
    if !t {
        println!("Success!")
    }
} </code></pre></pre>
<ol start="4">
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let f = true;
    let t = true &amp;&amp; false;
    assert_eq!(t, f);

    println!("Success!")
}</code></pre></pre>
<h3 id="单元类型"><a class="header" href="#单元类型">单元类型</a></h3>
<ol start="5">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 让代码工作，但不要修改 `implicitly_ret_unit` !
fn main() {
    let _v: () = ();

    let v = (2, 3);
    assert_eq!(v, implicitly_ret_unit());

    println!("Success!")
}

fn implicitly_ret_unit() {
    println!("I will return a ()")
}

// 不要使用下面的函数，它只用于演示！
fn explicitly_ret_unit() -&gt; () {
    println!("I will return a ()")
}</code></pre></pre>
<ol start="6">
<li>🌟🌟 单元类型占用的内存大小是多少？</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 让代码工作：修改 `assert!` 中的 `4` 
use std::mem::size_of_val;
fn main() {
    let unit: () = ();
    assert!(size_of_val(&amp;unit) == 4);

    println!("Success!")
}</code></pre></pre>
<blockquote>
<p>你可以在<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/basic-types/char-bool.md">这里</a>找到答案(在 solutions 路径下)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="语句与表达式"><a class="header" href="#语句与表达式">语句与表达式</a></h1>
<h3 id="示例"><a class="header" href="#示例">示例</a></h3>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let x = 5u32;

    let y = {
        let x_squared = x * x;
        let x_cube = x_squared * x;

        // 下面表达式的值将被赋给 `y`
        x_cube + x_squared + x
    };

    let z = {
        // 分号让表达式变成了语句，因此返回的不再是表达式 `2 * x` 的值，而是语句的值 `()`
        2 * x;
    };

    println!("x is {:?}", x);
    println!("y is {:?}", y);
    println!("z is {:?}", z);
}</code></pre></pre>
<h3 id="练习"><a class="header" href="#练习">练习</a></h3>
<ol>
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 使用两种方法让代码工作起来
fn main() {
   let v = {
       let mut x = 1;
       x += 2
   };

   assert_eq!(v, 3);
}</code></pre></pre>
<ol start="2">
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
   let v = (let x = 3);

   assert!(v == 3);
}</code></pre></pre>
<ol start="3">
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let s = sum(1 , 2);
    assert_eq!(s, 3);
}

fn sum(x: i32, y: i32) -&gt; i32 {
    x + y;
}</code></pre></pre>
<blockquote>
<p>你可以在<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/basic-types/statements.md">这里</a>找到答案(在 solutions 路径下)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="函数"><a class="header" href="#函数">函数</a></h1>
<ol>
<li>🌟🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    // 不要修改下面两行代码!
    let (x, y) = (1, 2);
    let s = sum(x, y);

    assert_eq!(s, 3);
}

fn sum(x, y: i32) {
    x + y;
}</code></pre></pre>
<ol start="2">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
   print();
}

// 使用另一个类型来替代 i32
fn print() -&gt; i32 {
   println!("hello,world");
}</code></pre></pre>
<ol start="3">
<li>🌟🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 用两种方法求解
fn main() {
    never_return();
}

fn never_return() -&gt; ! {
    // 实现这个函数，不要修改函数签名!
    
}</code></pre></pre>
<ol start="4">
<li>🌟🌟 发散函数( Diverging function )不会返回任何值，因此它们可以用于替代需要返回任何值的地方</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    println!("Success!");
}

fn get_option(tp: u8) -&gt; Option&lt;i32&gt; {
    match tp {
        1 =&gt; {
            // TODO
        }
        _ =&gt; {
            // TODO
        }
    };
    
    // 这里与其返回一个 None，不如使用发散函数替代
    never_return_fn()
}

// 使用三种方法实现以下发散函数
fn never_return_fn() -&gt; ! {
    
}</code></pre></pre>
<ol start="5">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    // 填空
    let b = __;

    let _v = match b {
        true =&gt; 1,
        // 发散函数也可以用于 `match` 表达式，用于替代任何类型的值
        false =&gt; {
            println!("Success!");
            panic!("we have no value for `false`, but we can panic")
        }
    };

    println!("Exercise Failed if printing out this line!");
}</code></pre></pre>
<blockquote>
<p>你可以在<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/basic-types/functions.md">这里</a>找到答案(在 solutions 路径下)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="所有权与借用"><a class="header" href="#所有权与借用">所有权与借用</a></h1>
<p>学习资料 :</p>
<ul>
<li>English: <a href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html">Rust Book 4.1-4.4</a></li>
<li>简体中文: <a href="https://course.rs/basic/ownership/index.html">Rust语言圣经 - 所有权与借用</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="所有权"><a class="header" href="#所有权">所有权</a></h1>
<ol>
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    // 使用尽可能多的方法来通过编译
    let x = String::from("hello, world");
    let y = x;
    println!("{},{}",x,y);
}</code></pre></pre>
<ol start="2">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 不要修改 main 中的代码
fn main() {
    let s1 = String::from("hello, world");
    let s2 = take_ownership(s1);

    println!("{}", s2);
}

// 只能修改下面的代码!
fn take_ownership(s: String) {
    println!("{}", s);
}</code></pre></pre>
<ol start="3">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let s = give_ownership();
    println!("{}", s);
}

// 只能修改下面的代码!
fn give_ownership() -&gt; String {
    let s = String::from("hello, world");
    // convert String to Vec
    // 将 String 转换成 Vec 类型
    let _s = s.into_bytes();
    s
}</code></pre></pre>
<ol start="4">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 修复错误，不要删除任何代码行
fn main() {
    let s = String::from("hello, world");

    print_str(s);

    println!("{}", s);
}

fn print_str(s: String)  {
    println!("{}",s)
}</code></pre></pre>
<ol start="5">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 不要使用 clone，使用 copy 的方式替代
fn main() {
    let x = (1, 2, (), "hello".to_string());
    let y = x.clone();
    println!("{:?}, {:?}", x, y);
}</code></pre></pre>
<h4 id="可变性"><a class="header" href="#可变性">可变性</a></h4>
<p>当所有权转移时，可变性也可以随之改变。</p>
<ol start="6">
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let s = String::from("hello, ");
    
    // 只修改下面这行代码 !
    let s1 = s;

    s1.push_str("world")
}</code></pre></pre>
<ol start="7">
<li>🌟🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let x = Box::new(5);
    
    let ...      // 完成该行代码，不要修改其它行！
    
    *y = 4;
    
    assert_eq!(*x, 5);
}</code></pre></pre>
<h3 id="部分-move"><a class="header" href="#部分-move">部分 move</a></h3>
<p>当解构一个变量时，可以同时使用 <code>move</code> 和引用模式绑定的方式。当这么做时，部分 <code>move</code> 就会发生：变量中一部分的所有权被转移给其它变量，而另一部分我们获取了它的引用。</p>
<p>在这种情况下，原变量将无法再被使用，但是它没有转移所有权的那一部分依然可以使用，也就是之前被引用的那部分。</p>
<h4 id="示例-1"><a class="header" href="#示例-1">示例</a></h4>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    #[derive(Debug)]
    struct Person {
        name: String,
        age: Box&lt;u8&gt;,
    }

    let person = Person {
        name: String::from("Alice"),
        age: Box::new(20),
    };

    // 通过这种解构式模式匹配，person.name 的所有权被转移给新的变量 `name`
    // 但是，这里 `age` 变量却是对 person.age 的引用, 这里 ref 的使用相当于: let age = &amp;person.age 
    let Person { name, ref age } = person;

    println!("The person's age is {}", age);

    println!("The person's name is {}", name);

    // Error! 原因是 person 的一部分已经被转移了所有权，因此我们无法再使用它
    //println!("The person struct is {:?}", person);

    // 虽然 `person` 作为一个整体无法再被使用，但是 `person.age` 依然可以使用
    println!("The person's age from person struct is {}", person.age);
}</code></pre></pre>
<h4 id="练习-1"><a class="header" href="#练习-1">练习</a></h4>
<ol start="8">
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
   let t = (String::from("hello"), String::from("world"));

   let _s = t.0;

   // 仅修改下面这行代码，且不要使用 `_s`
   println!("{:?}", t);
}</code></pre></pre>
<ol start="9">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
   let t = (String::from("hello"), String::from("world"));

   // 填空，不要修改其它代码
   let (__, __) = __;

   println!("{:?}, {:?}, {:?}", s1, s2, t); // -&gt; "hello", "world", ("hello", "world")
}</code></pre></pre>
<blockquote>
<p>你可以在<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/ownership/ownership.md">这里</a>找到答案(在 solutions 路径下)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="引用和借用"><a class="header" href="#引用和借用">引用和借用</a></h1>
<h3 id="引用"><a class="header" href="#引用">引用</a></h3>
<ol>
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
   let x = 5;
   // 填写空白处
   let p = __;

   println!("x 的内存地址是 {:p}", p); // output: 0x16fa3ac84
}</code></pre></pre>
<ol start="2">
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let x = 5;
    let y = &amp;x;

    // 只能修改以下行
    assert_eq!(5, y);
}</code></pre></pre>
<ol start="3">
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 修复错误
fn main() {
    let mut s = String::from("hello, ");

    borrow_object(s)
}

fn borrow_object(s: &amp;String) {}</code></pre></pre>
<ol start="4">
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 修复错误
fn main() {
    let mut s = String::from("hello, ");

    push_str(s)
}

fn push_str(s: &amp;mut String) {
    s.push_str("world")
}</code></pre></pre>
<ol start="5">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let mut s = String::from("hello, ");

    // 填写空白处，让代码工作
    let p = __;
    
    p.push_str("world");
}</code></pre></pre>
<h4 id="ref"><a class="header" href="#ref">ref</a></h4>
<p><code>ref</code> 与 <code>&amp;</code> 类似，可以用来获取一个值的引用，但是它们的用法有所不同。</p>
<ol start="6">
<li>🌟🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let c = '中';

    let r1 = &amp;c;
    // 填写空白处，但是不要修改其它行的代码
    let __ r2 = c;

    assert_eq!(*r1, *r2);
    
    // 判断两个内存地址的字符串是否相等
    assert_eq!(get_addr(r1),get_addr(r2));
}

// 获取传入引用的内存地址的字符串形式
fn get_addr(r: &amp;char) -&gt; String {
    format!("{:p}", r)
}</code></pre></pre>
<h3 id="借用规则"><a class="header" href="#借用规则">借用规则</a></h3>
<ol start="7">
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 移除代码某个部分，让它工作
// 你不能移除整行的代码！
fn main() {
    let mut s = String::from("hello");

    let r1 = &amp;mut s;
    let r2 = &amp;mut s;

    println!("{}, {}", r1, r2);
}</code></pre></pre>
<h4 id="可变性-1"><a class="header" href="#可变性-1">可变性</a></h4>
<ol start="8">
<li>🌟 错误: 从不可变对象借用可变</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    // 通过修改下面一行代码来修复错误
    let  s = String::from("hello, ");

    borrow_object(&amp;mut s)
}

fn borrow_object(s: &amp;mut String) {}</code></pre></pre>
<ol start="9">
<li>🌟🌟 Ok: 从可变对象借用不可变</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 下面的代码没有任何错误
fn main() {
    let mut s = String::from("hello, ");

    borrow_object(&amp;s);
    
    s.push_str("world");
}

fn borrow_object(s: &amp;String) {}</code></pre></pre>
<h3 id="nll"><a class="header" href="#nll">NLL</a></h3>
<ol start="10">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 注释掉一行代码让它工作
fn main() {
    let mut s = String::from("hello, ");

    let r1 = &amp;mut s;
    r1.push_str("world");
    let r2 = &amp;mut s;
    r2.push_str("!");
    
    println!("{}",r1);
}</code></pre></pre>
<ol start="11">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let mut s = String::from("hello, ");

    let r1 = &amp;mut s;
    let r2 = &amp;mut s;

    // 在下面增加一行代码人为制造编译错误：cannot borrow `s` as mutable more than once at a time
    // 你不能同时使用 r1 和 r2
}</code></pre></pre>
<blockquote>
<p>你可以在<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/ownership/borrowing.md">这里</a>找到答案(在 solutions 路径下)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="复合类型"><a class="header" href="#复合类型">复合类型</a></h1>
<p>学习资料:</p>
<ul>
<li>English: <a href="https://doc.rust-lang.org/book/ch04-03-slices.html">Rust Book 4.3, 5.1, 6.1, 8.2</a></li>
<li>简体中文: <a href="https://course.rs/basic/compound-type/intro.html">Rust语言圣经 - 复合类型</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字符串"><a class="header" href="#字符串">字符串</a></h1>
<p>字符串字面量的类型是 <code>&amp;str</code>， 例如 <code>let s: &amp;str = "hello, world"</code> 中的 <code>"hello, world"</code> 的类型就是 <code>&amp;str</code>。</p>
<h3 id="str-和-str"><a class="header" href="#str-和-str"><code>str</code> 和 <code>&amp;str</code></a></h3>
<ol>
<li>🌟 正常情况下我们无法使用 <code>str</code> 类型，但是可以使用 <code>&amp;str</code> 来替代</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 修复错误，不要新增代码行
fn main() {
    let s: str = "hello, world";
}</code></pre></pre>
<ol start="2">
<li>🌟🌟 如果要使用 <code>str</code> 类型，只能配合 <code>Box</code>。  <code>&amp;</code> 可以用来将 <code>Box&lt;str&gt;</code> 转换为 <code>&amp;str</code> 类型</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 使用至少两种方法来修复错误
fn main() {
    let s: Box&lt;str&gt; = "hello, world".into();
    greetings(s)
}

fn greetings(s: &amp;str) {
    println!("{}",s)
}</code></pre></pre>
<h3 id="string"><a class="header" href="#string">String</a></h3>
<p><code>String</code> 是定义在标准库中的类型，分配在堆上，可以动态的增长。它的底层存储是动态字节数组的方式( <code>Vec&lt;u8&gt;</code> )，但是与字节数组不同，<code>String</code> 是 <code>UTF-8</code> 编码。</p>
<ol start="3">
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 填空
fn main() {
    let mut s = __;
    s.push_str("hello, world");
    s.push('!');

    assert_eq!(s, "hello, world!");
}</code></pre></pre>
<ol start="4">
<li>🌟🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 修复所有错误，并且不要新增代码行
fn main() {
    let  s = String::from("hello");
    s.push(',');
    s.push(" world");
    s += "!".to_string();

    println!("{}", s)
}</code></pre></pre>
<ol start="5">
<li>🌟🌟 我们可以用 <code>replace</code> 方法来替换指定的子字符串</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 填空
fn main() {
    let s = String::from("I like dogs");
    // 以下方法会重新分配一块内存空间，然后将修改后的字符串存在这里
    let s1 = s.__("dogs", "cats");

    assert_eq!(s1, "I like cats")
}</code></pre></pre>
<p>在标准库的 <a href="https://doc.rust-lang.org/std/string/struct.String.html">String</a> 模块中，有更多的实用方法，感兴趣的同学可以看看。</p>
<ol start="6">
<li>🌟🌟 你只能将 <code>String</code> 跟 <code>&amp;str</code> 类型进行拼接，并且 <code>String</code> 的所有权在此过程中会被 move</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 修复所有错误，不要删除任何一行代码
fn main() {
    let s1 = String::from("hello,");
    let s2 = String::from("world!");
    let s3 = s1 + s2; 
    assert_eq!(s3,"hello,world!");
    println!("{}",s1);
}</code></pre></pre>
<h3 id="str-和-string"><a class="header" href="#str-和-string"><code>&amp;str</code> 和 <code>String</code></a></h3>
<p>与 <code>str</code> 的很少使用相比，<code>&amp;str</code> 和 <code>String</code> 类型却非常常用，因此也非常重要。</p>
<ol start="7">
<li>🌟🌟 我们可以使用两种方法将 <code>&amp;str</code> 转换成 <code>String</code> 类型</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 使用至少两种方法来修复错误
fn main() {
    let s = "hello, world";
    greetings(s)
}

fn greetings(s: String) {
    println!("{}",s)
}</code></pre></pre>
<ol start="8">
<li>🌟🌟 我们可以使用 <code>String::from</code> 或 <code>to_string</code> 将 <code>&amp;str</code> 转换成 <code>String</code> 类型</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 使用两种方法来解决错误，不要新增代码行
fn main() {
    let s = "hello, world".to_string();
    let s1: &amp;str = s;
}</code></pre></pre>
<h3 id="字符串转义"><a class="header" href="#字符串转义">字符串转义</a></h3>
<ol start="9">
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // 你可以使用转义的方式来输出想要的字符，这里我们使用十六进制的值，例如 \x73 会被转义成小写字母 's'
    // 填空以输出 "I'm writing Rust"
    let byte_escape = "I'm writing Ru\x73__!";
    println!("What are you doing\x3F (\\x3F means ?) {}", byte_escape);

    // 也可以使用 Unicode 形式的转义字符
    let unicode_codepoint = "\u{211D}";
    let character_name = "\"DOUBLE-STRUCK CAPITAL R\"";

    println!("Unicode character {} (U+211D) is called {}",
                unicode_codepoint, character_name );

    // 还能使用 \ 来连接多行字符串
    let long_string = "String literals
                        can span multiple lines.
                        The linebreak and indentation here \
                         can be escaped too!";
    println!("{}", long_string);
}</code></pre></pre>
<ol start="10">
<li>🌟🌟🌟 有时候需要转义的字符很多，我们会希望使用更方便的方式来书写字符串: raw string.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">/* 填空并修复所有错误 */
fn main() {
    let raw_str = r"Escapes don't work here: \x3F \u{211D}";
    // 修改上面的行让代码工作
    assert_eq!(raw_str, "Escapes don't work here: ? ℝ");

    // 如果你希望在字符串中使用双引号，可以使用以下形式
    let quotes = r#"And then I said: "There is no escape!""#;
    println!("{}", quotes);

    // 如果希望在字符串中使用 # 号，可以如下使用：
    let  delimiter = r###"A string with "# in it. And even "##!"###;
    println!("{}", delimiter);

    // 填空
    let long_delimiter = __;
    assert_eq!(long_delimiter, "Hello, \"##\"")
}</code></pre></pre>
<h3 id="字节字符串"><a class="header" href="#字节字符串">字节字符串</a></h3>
<p>想要一个非 UTF-8 形式的字符串吗(我们之前的 <code>str</code>, <code>&amp;str</code>, <code>String</code> 都是 UTF-8 字符串) ? 可以试试字节字符串或者说字节数组:</p>
<p><strong>示例</strong>:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::str;

fn main() {
    // 注意，这并不是 `&amp;str` 类型了！
    let bytestring: &amp;[u8; 21] = b"this is a byte string";


    // 字节数组没有实现 `Display` 特征，因此只能使用 `Debug` 的方式去打印
    println!("A byte string: {:?}", bytestring);

    // 字节数组也可以使用转义
    let escaped = b"\x52\x75\x73\x74 as bytes";
    // ...但是不支持 unicode 转义
    // let escaped = b"\u{211D} is not allowed";
    println!("Some escaped bytes: {:?}", escaped);


    // raw string
    let raw_bytestring = br"\u{211D} is not escaped here";
    println!("{:?}", raw_bytestring);

    // 将字节数组转成 `str` 类型可能会失败
    if let Ok(my_str) = str::from_utf8(raw_bytestring) {
        println!("And the same as text: '{}'", my_str);
    }

    let _quotes = br#"You can also use "fancier" formatting, \
                    like with normal raw strings"#;

    // 字节数组可以不是 UTF-8 格式
    let shift_jis = b"\x82\xe6\x82\xa8\x82\xb1\x82\xbb"; // "ようこそ" in SHIFT-JIS

    // 但是它们未必能转换成 `str` 类型
    match str::from_utf8(shift_jis) {
        Ok(my_str) =&gt; println!("Conversion successful: '{}'", my_str),
        Err(e) =&gt; println!("Conversion failed: {:?}", e),
    };
}</code></pre></pre>
<p>如果大家想要了解更多关于字符串字面量、转义字符的话，可以看看 Rust Reference 的 <a href="https://doc.rust-lang.org/reference/tokens.html">'Tokens' 章节</a>.</p>
<h3 id="字符串索引string-index"><a class="header" href="#字符串索引string-index">字符串索引string index</a></h3>
<ol start="11">
<li>🌟🌟 你无法通过索引的方式去访问字符串中的某个字符，但是可以使用切片的方式 <code>&amp;s1[start..end]</code> ，但是<code>start</code> 和 <code>end</code> 必须准确落在字符的边界处.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let s1 = String::from("hi,中国");
    let h = s1[0]; // 修改当前行来修复错误，提示: `h` 字符在 UTF-8 格式中只需要 1 个字节来表示
    assert_eq!(h, "h");

    let h1 = &amp;s1[3..5];// 修改当前行来修复错误，提示: `中` 字符在 UTF-8 格式中需要 3 个字节来表示
    assert_eq!(h1, "中");
}</code></pre></pre>
<h3 id="操作-utf-8-字符串"><a class="header" href="#操作-utf-8-字符串">操作 UTF-8 字符串</a></h3>
<ol start="12">
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    // 填空，打印出 "你好，世界" 中的每一个字符
    for c in "你好，世界".__ {
        println!("{}", c)
    }
}</code></pre></pre>
<h4 id="utf8_slice"><a class="header" href="#utf8_slice">utf8_slice</a></h4>
<p>我们可以使用三方库 <a href="https://docs.rs/utf8_slice/1.0.0/utf8_slice/fn.slice.html">utf8_slice</a> 来访问 UTF-8 字符串的某个子串，但是与之前不同的是，该库索引的是字符，而不是字节.</p>
<p><strong>Example</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021">use utf8_slice;
fn main() {
    let s = "The 🚀 goes to the 🌑!";

    let rocket = utf8_slice::slice(s, 4, 5);
    // 结果是 "🚀"
}</code></pre></pre>
<blockquote>
<p>你可以在<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/compound-types/string.md">这里</a>找到答案(在 solutions 路径下)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数组"><a class="header" href="#数组">数组</a></h1>
<p>数组的类型是 <code>[T; Length]</code>，就如你所看到的，数组的长度是类型签名的一部分，因此数组的长度必须在编译期就已知，例如你不能使用以下方式来声明一个数组:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_arr(n: i32) {
    let arr = [1; n];
}
<span class="boring">}</span></code></pre></pre>
<p>以上函数将报错，因为编译器无法在编译期知道 <code>n</code> 的具体大小。</p>
<ol>
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    // 使用合适的类型填空
    let arr: __ = [1, 2, 3, 4, 5];

    // 修改以下代码，让它顺利运行
    assert!(arr.len() == 4);
}</code></pre></pre>
<ol start="2">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    // 很多时候，我们可以忽略数组的部分类型，也可以忽略全部类型，让编译器帮助我们推导
    let arr0 = [1, 2, 3];
    let arr: [_; 3] = ['a', 'b', 'c'];
    
    // 填空
    // 数组分配在栈上， `std::mem::size_of_val` 函数会返回整个数组占用的内存空间
    // 数组中的每个 char 元素占用 4 字节的内存空间，因为在 Rust 中， char 是 Unicode 字符
    assert!(std::mem::size_of_val(&amp;arr) == __);
}</code></pre></pre>
<ol start="3">
<li>🌟 数组中的所有元素可以一起初始化为同一个值</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    // 填空
    let list: [i32; 100] = __ ;

    assert!(list[0] == 1);
    assert!(list.len() == 100);
}</code></pre></pre>
<ol start="4">
<li>🌟 数组中的所有元素必须是同一类型</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    // 修复错误
    let _arr = [1, 2, '3'];
}</code></pre></pre>
<ol start="5">
<li>🌟 数组的下标索引从 0 开始.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let arr = ['a', 'b', 'c'];
    
    let ele = arr[1]; // 只修改此行来让代码工作

    assert!(ele == 'a');
}</code></pre></pre>
<ol start="6">
<li>🌟 越界索引会导致代码的 <code>panic</code>.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 修复代码中的错误
fn main() {
    let names = [String::from("Sunfei"), "Sunface".to_string()];
    
    // `get` 返回 `Option&lt;T&gt;` 类型，因此它的使用非常安全
    let name0 = names.get(0).unwrap();

    // 但是下标索引就存在越界的风险了
    let _name1 = &amp;names[2];
}</code></pre></pre>
<blockquote>
<p>你可以在<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/compound-types/array.md">这里</a>找到答案(在 solutions 路径下)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="切片-slice-"><a class="header" href="#切片-slice-">切片( Slice )</a></h1>
<p>切片跟数组相似，但是切片的长度无法在编译期得知，因此你无法直接使用切片类型。</p>
<ol>
<li>🌟🌟 这里, <code>[i32]</code> 和 <code>str</code> 都是切片类型，但是直接使用它们会造成编译错误，如下代码所示。为了解决，你需要使用切片的引用： <code>&amp;[i32]</code>，<code>&amp;str</code>。</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 修复代码中的错误，不要新增代码行!
fn main() {
    let arr = [1, 2, 3];
    let s1: [i32] = arr[0..2];

    let s2: str = "hello, world" as str;
}</code></pre></pre>
<p>一个切片引用占用了2个字大小的内存空间( 从现在开始，为了简洁性考虑，如无特殊原因，<strong>我们统一使用切片来特指切片引用</strong> )。 该切片的第一个字是指向数据的指针，第二个字是切片的长度。字的大小取决于处理器架构，例如在 <code>x86-64</code> 上，字的大小是 64 位也就是 8 个字节，那么一个切片引用就是 16 个字节大小。</p>
<p>切片( 引用 )可以用来借用数组的某个连续的部分，对应的签名是 <code>&amp;[T]</code>，大家可以与数组的签名对比下 <code>[T; Length]</code>。</p>
<ol start="2">
<li>🌟🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let arr: [char; 3] = ['中', '国', '人'];

    let slice = &amp;arr[..2];
    
    // 修改数字 `8` 让代码工作
    // 小提示: 切片和数组不一样，它是引用。如果是数组的话，那下面的 `assert!` 将会通过： '中'和'国'是char类型，char类型是Unicode编码，大小固定为4字节，两个字符为8字节。
    assert!(std::mem::size_of_val(&amp;slice) == 8);
}</code></pre></pre>
<ol start="3">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
   let arr: [i32; 5] = [1, 2, 3, 4, 5];
  // 填空让代码工作起来
  let slice: __ = __;
  assert_eq!(slice, &amp;[2, 3, 4]);
}</code></pre></pre>
<h3 id="字符串切片"><a class="header" href="#字符串切片">字符串切片</a></h3>
<ol start="4">
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let s = String::from("hello");

    let slice1 = &amp;s[0..2];
    // 填空，不要再使用 0..2
    let slice2 = &amp;s[__];

    assert_eq!(slice1, slice2);
}</code></pre></pre>
<ol start="5">
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let s = "你好，世界";
    // 修改以下代码行，让代码工作起来
    let slice = &amp;s[0..2];

    assert!(slice == "你");
}</code></pre></pre>
<ol start="6">
<li>🌟🌟 <code>&amp;String</code> 可以被隐式地转换成 <code>&amp;str</code> 类型.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 修复所有错误
fn main() {
    let mut s = String::from("hello world");

    // 这里, &amp;s 是 `&amp;String` 类型，但是 `first_character` 函数需要的是 `&amp;str` 类型。
    // 尽管两个类型不一样，但是代码仍然可以工作，原因是 `&amp;String` 会被隐式地转换成 `&amp;str` 类型，如果大家想要知道更多，可以看看 Deref 章节: https://course.rs/advance/smart-pointer/deref.html
    let ch = first_character(&amp;s);

    s.clear(); // error!

    println!("the first character is: {}", ch);
}
fn first_character(s: &amp;str) -&gt; &amp;str {
    &amp;s[..1]
}</code></pre></pre>
<blockquote>
<p>你可以在<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/compound-types/slice.md">这里</a>找到答案(在 solutions 路径下)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="元组-tuple-"><a class="header" href="#元组-tuple-">元组( Tuple )</a></h1>
<ol>
<li>🌟 元组中的元素可以是不同的类型。元组的类型签名是 <code>(T1, T2, ...)</code>, 这里 <code>T1</code>, <code>T2</code> 是相对应的元组成员的类型.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let _t0: (u8,i16) = (0, -1);
    // 元组的成员还可以是一个元组
    let _t1: (u8, (i16, u32)) = (0, (-1, 1));
    // 填空让代码工作
    let t: (u8, __, i64, __, __) = (1u8, 2u16, 3i64, "hello", String::from(", world"));
}</code></pre></pre>
<ol start="2">
<li>🌟 可以使用索引来获取元组的成员</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 修改合适的地方，让代码工作
fn main() {
    let t = ("i", "am", "sunface");
    assert_eq!(t.1, "sunface");
}</code></pre></pre>
<ol start="3">
<li>🌟 过长的元组无法被打印输出</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 修复代码错误
fn main() {
    let too_long_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13);
    println!("too long tuple: {:?}", too_long_tuple);
}</code></pre></pre>
<ol start="4">
<li>🌟 使用模式匹配来解构元组</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let tup = (1, 6.4, "hello");

    // 填空
    let __ = tup;

    assert_eq!(x, 1);
    assert_eq!(y, "hello");
    assert_eq!(z, 6.4);
}</code></pre></pre>
<ol start="5">
<li>🌟🌟 解构式赋值</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let (x, y, z);

    // 填空
    __ = (1, 2, 3);
    
    assert_eq!(x, 3);
    assert_eq!(y, 1);
    assert_eq!(z, 2);
}</code></pre></pre>
<ol start="6">
<li>🌟🌟 元组可以用于函数的参数和返回值</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    // 填空，需要稍微计算下
    let (x, y) = sum_multiply(__);

    assert_eq!(x, 5);
    assert_eq!(y, 6);
}

fn sum_multiply(nums: (i32, i32)) -&gt; (i32, i32) {
    (nums.0 + nums.1, nums.0 * nums.1)
}</code></pre></pre>
<blockquote>
<p>你可以在<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/compound-types/tuple.md">这里</a>找到答案(在 solutions 路径下)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="结构体"><a class="header" href="#结构体">结构体</a></h1>
<h3 id="三种类型的结构体"><a class="header" href="#三种类型的结构体">三种类型的结构体</a></h3>
<ol>
<li>🌟 对于结构体，我们必须为其中的每一个字段都指定具体的值</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix the error
struct Person {
    name: String,
    age: u8,
    hobby: String
}
fn main() {
    let age = 30;
    let p = Person {
        name: String::from("sunface"),
        age,
    };
} </code></pre></pre>
<ol start="2">
<li>🌟 单元结构体没有任何字段。</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
struct Unit;
trait SomeTrait {
    // ...定义一些行为
}

// 我们并不关心结构体中有什么数据( 字段 )，但我们关心它的行为。
// 因此这里我们使用没有任何字段的单元结构体，然后为它实现一些行为
impl SomeTrait for Unit {  }
fn main() {
    let u = Unit;
    do_something_with_unit(u);
} 

// 填空，让代码工作
fn do_something_with_unit(u: __) {   }</code></pre></pre>
<ol start="3">
<li>🌟🌟🌟 元组结构体看起来跟元组很像，但是它拥有一个结构体的名称，该名称可以赋予它一定的意义。由于它并不关心内部数据到底是什么名称，因此此时元组结构体就非常适合。</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 填空并修复错误
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);
fn main() {
    let v = Point(__, __, __);
    check_color(v);
}   

fn check_color(p: Color) {
    let (x, _, _) = p;
    assert_eq!(x, 0);
    assert_eq!(p.1, 127);
    assert_eq!(__, 255);
 }</code></pre></pre>
<h3 id="结构体上的一些操作"><a class="header" href="#结构体上的一些操作">结构体上的一些操作</a></h3>
<ol start="4">
<li>🌟 你可以在实例化一个结构体时将它整体标记为可变的，但是 Rust 不允许我们将结构体的某个字段专门指定为可变的.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 填空并修复错误，不要增加或移除代码行
struct Person {
    name: String,
    age: u8,
}
fn main() {
    let age = 18;
    let p = Person {
        name: String::from("sunface"),
        age,
    };

    // how can you believe sunface is only 18? 
    p.age = 30;

    // 填空
    __ = String::from("sunfei");
}</code></pre></pre>
<ol start="5">
<li>🌟 使用结构体字段初始化缩略语法可以减少一些重复代码</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 填空
struct Person {
    name: String,
    age: u8,
}
fn main() {} 

fn build_person(name: String, age: u8) -&gt; Person {
    Person {
        age,
        __
    }
}</code></pre></pre>
<ol start="6">
<li>🌟 你可以使用结构体更新语法基于一个结构体实例来构造另一个</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 填空，让代码工作
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
fn main() {
    let u1 = User {
        email: String::from("someone@example.com"),
        username: String::from("sunface"),
        active: true,
        sign_in_count: 1,
    };

    let u2 = set_email(u1);
} 

fn set_email(u: User) -&gt; User {
    User {
        email: String::from("contact@im.dev"),
        __
    }
}</code></pre></pre>
<h3 id="打印结构体"><a class="header" href="#打印结构体">打印结构体</a></h3>
<ol start="7">
<li>🌟🌟 我们可以使用 <code>#[derive(Debug)]</code> 让<a href="https://course.rs/basic/compound-type/struct.html#%E4%BD%BF%E7%94%A8-derivedebug-%E6%9D%A5%E6%89%93%E5%8D%B0%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E4%BF%A1%E6%81%AF">结构体变成可打印的</a>.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 填空，让代码工作
#[__]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        width: dbg!(30 * scale), // 打印 debug 信息到标准错误输出 stderr,并将 `30 * scale` 的值赋给 `width`
        height: 50,
    };

    dbg!(&amp;rect1); // 打印 debug 信息到标准错误输出 stderr

    println!(__, rect1); // 打印 debug 信息到标准输出 stdout
}</code></pre></pre>
<h3 id="结构体的所有权"><a class="header" href="#结构体的所有权">结构体的所有权</a></h3>
<p>当解构一个变量时，可以同时使用 <code>move</code> 和引用模式绑定的方式。当这么做时，部分 <code>move</code> 就会发生：变量中一部分的所有权被转移给其它变量，而另一部分我们获取了它的引用。</p>
<p>在这种情况下，原变量将无法再被使用，但是它没有转移所有权的那一部分依然可以使用，也就是之前被引用的那部分。</p>
<h4 id="示例-2"><a class="header" href="#示例-2">示例</a></h4>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    #[derive(Debug)]
    struct Person {
        name: String,
        age: Box&lt;u8&gt;,
    }

    let person = Person {
        name: String::from("Alice"),
        age: Box::new(20),
    };

    // 通过这种解构式模式匹配，person.name 的所有权被转移给新的变量 `name`
    // 但是，这里 `age` 变量却是对 person.age 的引用, 这里 ref 的使用相当于: let age = &amp;person.age 
    let Person { name, ref age } = person;

    println!("The person's age is {}", age);

    println!("The person's name is {}", name);

    // Error! 原因是 person 的一部分已经被转移了所有权，因此我们无法再使用它
    //println!("The person struct is {:?}", person);

    // 虽然 `person` 作为一个整体无法再被使用，但是 `person.age` 依然可以使用
    println!("The person's age from person struct is {}", person.age);
}</code></pre></pre>
<h4 id="练习-2"><a class="header" href="#练习-2">练习</a></h4>
<ol start="8">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 修复错误
#[derive(Debug)]
struct File {
    name: String,
    data: String,
}
fn main() {
    let f = File {
        name: String::from("readme.md"),
        data: "Rust By Practice".to_string()
    };

    let _name = f.name;

    // 只能修改这一行
    println!("{}, {}, {:?}",f.name, f.data, f);
} </code></pre></pre>
<blockquote>
<p>你可以在<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/compound-types/struct.md">这里</a>找到答案(在 solutions 路径下)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="枚举-enum"><a class="header" href="#枚举-enum">枚举 Enum</a></h1>
<ol>
<li>🌟🌟 在创建枚举时，你可以使用显式的整数设定枚举成员的值。</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 修复错误
enum Number {
    Zero,
    One,
    Two,
}

enum Number1 {
    Zero = 0,
    One,
    Two,
}

// C语言风格的枚举定义
enum Number2 {
    Zero = 0.0,
    One = 1.0,
    Two = 2.0,
}


fn main() {
    // 通过 `as` 可以将枚举值强转为整数类型
    assert_eq!(Number::One, Number1::One);
    assert_eq!(Number1::One, Number2::One);
} </code></pre></pre>
<ol start="2">
<li>🌟 枚举成员可以持有各种类型的值</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 填空
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg1 = Message::Move{__}; // 使用x = 1, y = 2 来初始化
    let msg2 = Message::Write(__); // 使用 "hello, world!" 来初始化
} </code></pre></pre>
<ol start="3">
<li>🌟🌟 枚举成员中的值可以使用模式匹配来获取</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 仅填空并修复错误
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::Move{x: 1, y: 2};

    if let Message::Move{__} = msg {
        assert_eq!(a, b);
    } else {
        panic!("不要让这行代码运行！");
    }
} </code></pre></pre>
<ol start="4">
<li>🌟🌟 使用枚举对类型进行同一化</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 填空，并修复错误
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msgs: __ = [
        Message::Quit,
        Message::Move{x:1, y:3},
        Message::ChangeColor(255,255,0)
    ];

    for msg in msgs {
        show_message(msg)
    }
} 

fn show_message(msg: Message) {
    println!("{}", msg);
}</code></pre></pre>
<ol start="5">
<li>🌟🌟 Rust 中没有 <code>null</code>，我们通过 <code>Option&lt;T&gt;</code> 枚举来处理值为空的情况</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 填空让 `println` 输出，同时添加一些代码不要让最后一行的 `panic` 执行到
fn main() {
    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);

    if let __ = six {
        println!("{}", n)
    } 
        
    panic!("不要让这行代码运行！");
} 

fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        __ =&gt; None,
        __ =&gt; Some(i + 1),
    }
}</code></pre></pre>
<ol start="6">
<li>🌟🌟🌟🌟 使用枚举来实现链表.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 填空，让代码运行
use crate::List::*;

enum List {
    // Cons: 链表中包含有值的节点，节点是元组类型，第一个元素是节点的值，第二个元素是指向下一个节点的指针
    Cons(u32, Box&lt;List&gt;),
    // Nil: 链表中的最后一个节点，用于说明链表的结束
    Nil,
}

// 为枚举实现一些方法
impl List {
    // 创建空的链表
    fn new() -&gt; List {
        // 因为没有节点，所以直接返回 Nil 节点
        // 枚举成员 Nil 的类型是 List
        Nil
    }

    // 在老的链表前面新增一个节点，并返回新的链表
    fn prepend(self, elem: u32) -&gt; __ {
        Cons(elem, Box::new(self))
    }

    // 返回链表的长度
    fn len(&amp;self) -&gt; u32 {
        match *self {
            // 这里我们不能拿走 tail 的所有权，因此需要获取它的引用
            Cons(_, __ tail) =&gt; 1 + tail.len(),
            // 空链表的长度为 0
            Nil =&gt; 0
        }
    }

    // 返回链表的字符串表现形式，用于打印输出
    fn stringify(&amp;self) -&gt; String {
        match *self {
            Cons(head, ref tail) =&gt; {
                // 递归生成字符串
                format!("{}, {}", head, tail.__())
            },
            Nil =&gt; {
                format!("Nil")
            },
        }
    }
}

fn main() {
    // 创建一个新的链表(也是空的)
    let mut list = List::new();

    // 添加一些元素
    list = list.prepend(1);
    list = list.prepend(2);
    list = list.prepend(3);

    // 打印列表的当前状态
    println!("链表的长度是: {}", list.len());
    println!("{}", list.stringify());
}</code></pre></pre>
<blockquote>
<p>你可以在<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/compound-types/enum.md">这里</a>找到答案(在 solutions 路径下)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="流程控制"><a class="header" href="#流程控制">流程控制</a></h1>
<h3 id="ifelse"><a class="header" href="#ifelse">if/else</a></h3>
<ol>
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 填空
fn main() {
    let n = 5;

    if n &lt; 0 {
        println!("{} is negative", n);
    } __ n &gt; 0 {
        println!("{} is positive", n);
    } __ {
        println!("{} is zero", n);
    }
} </code></pre></pre>
<ol start="2">
<li>🌟🌟 if/else 可以用作表达式来进行赋值</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 修复错误
fn main() {
    let n = 5;

    let big_n =
        if n &lt; 10 &amp;&amp; n &gt; -10 {
            println!(" 数字太小，先增加 10 倍再说");

            10 * n
        } else {
            println!("数字太大，我们得让它减半");

            n / 2.0 ;
        }

    println!("{} -&gt; {}", n, big_n);
} </code></pre></pre>
<h3 id="for"><a class="header" href="#for">for</a></h3>
<ol start="3">
<li>🌟 <code>for in</code> 可以用于迭代一个迭代器，例如序列 <code>a..b</code>.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    for n in 1..=100 { // 修改此行，让代码工作
        if n == 100 {
            panic!("NEVER LET THIS RUN")
        }
    }
} </code></pre></pre>
<ol start="4">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 修复错误，不要新增或删除代码行
fn main() {
    let names = [String::from("liming"),String::from("hanmeimei")];
    for name in names {
        // do something with name...
    }

    println!("{:?}", names);

    let numbers = [1, 2, 3];
    // numbers中的元素实现了 Copy，因此无需转移所有权
    for n in numbers {
        // do something with name...
    }
    
    println!("{:?}", numbers);
} </code></pre></pre>
<ol start="5">
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let a = [4,3,2,1];

    // 通过索引和值的方式迭代数组 `a` 
    for (i,v) in a.__ {
        println!("第{}个元素是{}",i+1,v);
    }
}</code></pre></pre>
<h3 id="while"><a class="header" href="#while">while</a></h3>
<ol start="6">
<li>🌟🌟 当条件为 true 时，<code>while</code> 将一直循环</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 填空，让最后一行的  println! 工作 !
fn main() {
    // 一个计数值
    let mut n = 1;

    // 当条件为真时，不停的循环
    while n __ 10 {
        if n % 15 == 0 {
            println!("fizzbuzz");
        } else if n % 3 == 0 {
            println!("fizz");
        } else if n % 5 == 0 {
            println!("buzz");
        } else {
            println!("{}", n);
        }


        __;
    }

    println!("n 的值是 {}, 循环结束",n);
}</code></pre></pre>
<h3 id="continue-and-break"><a class="header" href="#continue-and-break">continue and break</a></h3>
<ol start="7">
<li>🌟 使用 <code>break</code> 可以跳出循环</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 填空，不要修改其它代码
fn main() {
    let mut n = 0;
    for i in 0..=100 {
       if n == 66 {
           __
       }
       n += 1;
    }

    assert_eq!(n, 66);
}</code></pre></pre>
<ol start="8">
<li>🌟🌟 <code>continue</code> 会结束当次循环并立即开始下一次循环</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 填空，不要修改其它代码
fn main() {
    let mut n = 0;
    for i in 0..=100 {
       if n != 66 {
           n+=1;
           __;
       }
       
       __
    }

    assert_eq!(n, 66);
}</code></pre></pre>
<h3 id="loop"><a class="header" href="#loop">loop</a></h3>
<ol start="9">
<li>🌟🌟 loop 一般都需要配合 <code>break</code> 或 <code>continue</code> 一起使用。</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 填空，不要修改其它代码
fn main() {
    let mut count = 0u32;

    println!("Let's count until infinity!");

    // 无限循环
    loop {
        count += 1;

        if count == 3 {
            println!("three");

            // 跳过当前循环的剩余代码
            __;
        }

        println!("{}", count);

        if count == 5 {
            println!("OK, that's enough");

            __;
        }
    }

    assert_eq!(count, 5);
}</code></pre></pre>
<ol start="10">
<li>🌟🌟 loop 是一个表达式，因此我们可以配合 <code>break</code> 来返回一个值</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 填空
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            __;
        }
    };

    assert_eq!(result, 20);
}</code></pre></pre>
<ol start="11">
<li>🌟🌟🌟 当有多层循环时，你可以使用 <code>continue</code> 或 <code>break</code> 来控制外层的循环。要实现这一点，外部的循环必须拥有一个标签 <code>'label</code>, 然后在 <code>break</code> 或 <code>continue</code> 时指定该标签</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 填空
fn main() {
    let mut count = 0;
    'outer: loop {
        'inner1: loop {
            if count &gt;= 20 {
                // 这只会跳出 inner1 循环
                break 'inner1; // 这里使用 `break` 也是一样的
            }
            count += 2;
        }

        count += 5;

        'inner2: loop {
            if count &gt;= 30 {
                break 'outer;
            }

            continue 'outer;
        }
    }

    assert!(count == __)
}</code></pre></pre>
<blockquote>
<p>你可以在<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/flow-control.md">这里</a>找到答案(在 solutions 路径下)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-match"><a class="header" href="#pattern-match">Pattern Match</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="match-matches-和-if-let"><a class="header" href="#match-matches-和-if-let">match, matches! 和 if let</a></h1>
<h3 id="match"><a class="header" href="#match">match</a></h3>
<ol>
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 填空
enum Direction {
    East,
    West,
    North,
    South,
}

fn main() {
    let dire = Direction::South;
    match dire {
        Direction::East =&gt; println!("East"),
        __  =&gt; { // 在这里匹配 South 或 North
            println!("South or North");
        },
        _ =&gt; println!(__),
    };
}</code></pre></pre>
<ol start="2">
<li>🌟🌟 <code>match</code> 是一个表达式，因此可以用在赋值语句中</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let boolean = true;

    // 使用 match 表达式填空，并满足以下条件
    //
    // boolean = true =&gt; binary = 1
    // boolean = false =&gt; binary = 0
    let binary = __;

    assert_eq!(binary, 1);
}</code></pre></pre>
<ol start="3">
<li>🌟🌟 使用 match 匹配出枚举成员持有的值</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 填空
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msgs = [
        Message::Quit,
        Message::Move{x:1, y:3},
        Message::ChangeColor(255,255,0)
    ];

    for msg in msgs {
        show_message(msg)
    }
} 

fn show_message(msg: Message) {
    match msg {
        __ =&gt; { // 这里匹配 Message::Move
            assert_eq!(a, 1);
            assert_eq!(b, 3);
        },
        Message::ChangeColor(_, g, b) =&gt; {
            assert_eq!(g, __);
            assert_eq!(b, __);
        }
        __ =&gt; println!("no data in these variants")
    }
}</code></pre></pre>
<h3 id="matches"><a class="header" href="#matches">matches!</a></h3>
<p><a href="https://doc.rust-lang.org/stable/core/macro.matches.html"><code>matches!</code></a> 看起来像 <code>match</code>, 但是它可以做一些特别的事情</p>
<ol start="4">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let alphabets = ['a', 'E', 'Z', '0', 'x', '9' , 'Y'];

    // 使用 `matches` 填空
    for ab in alphabets {
        assert!(__)
    }
} </code></pre></pre>
<ol start="5">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
enum MyEnum {
    Foo,
    Bar
}

fn main() {
    let mut count = 0;

    let v = vec![MyEnum::Foo,MyEnum::Bar,MyEnum::Foo];
    for e in v {
        if e == MyEnum::Foo { // 修复错误，只能修改本行代码
            count += 1;
        }
    }

    assert_eq!(count, 2);
}</code></pre></pre>
<h3 id="if-let"><a class="header" href="#if-let">if let</a></h3>
<p>在有些时候, 使用 <code>match</code> 匹配枚举有些太重了，此时 <code>if let</code> 就非常适合.</p>
<ol start="6">
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let o = Some(7);

    // 移除整个 `match` 语句块，使用 `if let` 替代
    match o {
        Some(i) =&gt; {
            println!("This is a really long string and `{:?}`", i);
        }
        _ =&gt; {}
    };
}</code></pre></pre>
<ol start="7">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 填空
enum Foo {
    Bar(u8)
}

fn main() {
    let a = Foo::Bar(1);

    __ {
        println!("foobar 持有的值是: {}", i);
    }
}</code></pre></pre>
<ol start="8">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
enum Foo {
    Bar,
    Baz,
    Qux(u32)
}

fn main() {
    let a = Foo::Qux(10);

    // 移除以下代码，使用 `match` 代替
    if let Foo::Bar = a {
        println!("match foo::bar")
    } else if let Foo::Baz = a {
        println!("match foo::baz")
    } else {
        println!("match others")
    }
}</code></pre></pre>
<h3 id="变量遮蔽-shadowing--1"><a class="header" href="#变量遮蔽-shadowing--1">变量遮蔽( Shadowing )</a></h3>
<ol start="9">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 就地修复错误
fn main() {
    let age = Some(30);
    if let Some(age) = age { // 创建一个新的变量，该变量与之前的 `age` 变量同名
       assert_eq!(age, Some(30));
    } // 新的 `age` 变量在这里超出作用域
    
    match age {
        // `match` 也能实现变量遮蔽
        Some(age) =&gt;  println!("age 是一个新的变量，它的值是 {}",age),
        _ =&gt; ()
    }
 }</code></pre></pre>
<blockquote>
<p>你可以在<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/pattern-match/match.md">这里</a>找到答案(在 solutions 路径下)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模式"><a class="header" href="#模式">模式</a></h1>
<ol>
<li>🌟🌟 使用 <code>|</code> 可以匹配多个值, 而使用 <code>..=</code> 可以匹配一个闭区间的数值序列</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {}
fn match_number(n: i32) {
    match n {
        // 匹配一个单独的值
        1 =&gt; println!("One!"),
        // 使用 `|` 填空，不要使用 `..` 或 `..=`
        __ =&gt; println!("match 2 -&gt; 5"),
        // 匹配一个闭区间的数值序列
        6..=10 =&gt; {
            println!("match 6 -&gt; 10")
        },
        _ =&gt; {
            println!("match 11 -&gt; +infinite")
        }
    }
}</code></pre></pre>
<ol start="2">
<li>🌟🌟🌟  <code>@</code> 操作符可以让我们将一个与模式相匹配的值绑定到新的变量上</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    // 填空，让 p 匹配第二个分支
    let p = Point { x: __, y: __ };

    match p {
        Point { x, y: 0 } =&gt; println!("On the x axis at {}", x),
        // 第二个分支
        Point { x: 0..=5, y: y@ (10 | 20 | 30) } =&gt; println!("On the y axis at {}", y),
        Point { x, y } =&gt; println!("On neither axis: ({}, {})", x, y),
    }
}</code></pre></pre>
<ol start="3">
<li>🌟🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 修复错误
enum Message {
    Hello { id: i32 },
}

fn main() {
    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {
            id:  3..=7,
        } =&gt; println!("id 值的范围在 [3, 7] 之间: {}", id),
        Message::Hello { id: newid@10 | 11 | 12 } =&gt; {
            println!("id 值的范围在 [10, 12] 之间: {}", newid)
        }
        Message::Hello { id } =&gt; println!("Found some other id: {}", id),
    }
}</code></pre></pre>
<ol start="4">
<li>🌟🌟 匹配守卫（match guard）是一个位于 match 分支模式之后的额外 if 条件，它能为分支模式提供更进一步的匹配条件。</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 填空让代码工作，必须使用 `split`
fn main() {
    let num = Some(4);
    let split = 5;
    match num {
        Some(x) __ =&gt; assert!(x &lt; split),
        Some(x) =&gt; assert!(x &gt;= split),
        None =&gt; (),
    }
}</code></pre></pre>
<ol start="5">
<li>🌟🌟🌟 使用 <code>..</code> 忽略一部分值</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 填空，让代码工作
fn main() {
    let numbers = (2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048);

    match numbers {
        __ =&gt; {
           assert_eq!(first, 2);
           assert_eq!(last, 2048);
        }
    }
}</code></pre></pre>
<ol start="6">
<li>🌟🌟 使用模式 <code>&amp;mut V</code> 去匹配一个可变引用时，你需要格外小心，因为匹配出来的 <code>V</code> 是一个值，而不是可变引用</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 修复错误，尽量少地修改代码
// 不要移除任何代码行
fn main() {
    let mut v = String::from("hello,");
    let r = &amp;mut v;

    match r {
       &amp;mut value =&gt; value.push_str(" world!") 
    }
}</code></pre></pre>
<blockquote>
<p>你可以在<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/pattern-match/patterns.md">这里</a>找到答案(在 solutions 路径下)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="方法和关联函数"><a class="header" href="#方法和关联函数">方法和关联函数</a></h1>
<h2 id="示例-3"><a class="header" href="#示例-3">示例</a></h2>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Point {
    x: f64,
    y: f64,
}

// `Point` 的关联函数都放在下面的 `impl` 语句块中
impl Point {
    // 关联函数的使用方法跟构造器非常类似
    fn origin() -&gt; Point {
        Point { x: 0.0, y: 0.0 }
    }

    // 另外一个关联函数，有两个参数
    fn new(x: f64, y: f64) -&gt; Point {
        Point { x: x, y: y }
    }
}

struct Rectangle {
    p1: Point,
    p2: Point,
}

impl Rectangle {
    // 这是一个方法
    // `&amp;self` 是 `self: &amp;Self` 的语法糖
    // `Self` 是当前调用对象的类型，对于本例来说 `Self` = `Rectangle`
    fn area(&amp;self) -&gt; f64 {
        // 使用点操作符可以访问 `self` 中的结构体字段
        let Point { x: x1, y: y1 } = self.p1;
        let Point { x: x2, y: y2 } = self.p2;

  
        // `abs` 是一个 `f64` 类型的方法，会返回调用者的绝对值
        ((x1 - x2) * (y1 - y2)).abs()
    }

    fn perimeter(&amp;self) -&gt; f64 {
        let Point { x: x1, y: y1 } = self.p1;
        let Point { x: x2, y: y2 } = self.p2;

        2.0 * ((x1 - x2).abs() + (y1 - y2).abs())
    }

    // 该方法要求调用者是可变的，`&amp;mut self` 是 `self: &amp;mut Self` 的语法糖
    fn translate(&amp;mut self, x: f64, y: f64) {
        self.p1.x += x;
        self.p2.x += x;

        self.p1.y += y;
        self.p2.y += y;
    }
}

// `Pair` 持有两个分配在堆上的整数
struct Pair(Box&lt;i32&gt;, Box&lt;i32&gt;);

impl Pair {
    // 该方法会拿走调用者的所有权
    // `self` 是 `self: Self` 的语法糖
    fn destroy(self) {
        let Pair(first, second) = self;

        println!("Destroying Pair({}, {})", first, second);

        // `first` 和 `second` 在这里超出作用域并被释放
    }
}

fn main() {
    let rectangle = Rectangle {
        // 关联函数的调用不是通过点操作符，而是使用 `::`
        p1: Point::origin(),
        p2: Point::new(3.0, 4.0),
    };

    // 方法才是通过点操作符调用
    // 注意，这里的方法需要的是 `&amp;self` 但是我们并没有使用 `(&amp;rectangle).perimeter()` 来调用，原因在于：
    // 编译器会帮我们自动取引用
    //  `rectangle.perimeter()` === `Rectangle::perimeter(&amp;rectangle)`
    println!("Rectangle perimeter: {}", rectangle.perimeter());
    println!("Rectangle area: {}", rectangle.area());

    let mut square = Rectangle {
        p1: Point::origin(),
        p2: Point::new(1.0, 1.0),
    };


    // 错误！`rectangle` 是不可变的，但是这个方法要求一个可变的对象
    //rectangle.translate(1.0, 0.0);
    // TODO ^ 试着反注释此行，看看会发生什么

    // 可以！可变对象可以调用可变的方法
    square.translate(1.0, 1.0);

    let pair = Pair(Box::new(1), Box::new(2));

    pair.destroy();

    // Error! 上一个 `destroy` 调用拿走了 `pair` 的所有权
    //pair.destroy();
    // TODO ^ 试着反注释此行
}</code></pre></pre>
<h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2>
<h3 id="method"><a class="header" href="#method">Method</a></h3>
<ol>
<li>🌟🌟 方法跟函数类似：都是使用 <code>fn</code> 声明，有参数和返回值。但是与函数不同的是，方法定义在结构体的上下文中(枚举、特征对象也可以定义方法)，而且方法的第一个参数一定是 <code>self</code> 或其变体 <code>&amp;self</code> 、<code>&amp;mut self</code>，<code>self</code> 代表了当前调用的结构体实例。</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    // 完成 area 方法，返回矩形 Rectangle 的面积
    fn area
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    assert_eq!(rect1.area(), 1500);
}</code></pre></pre>
<ol start="2">
<li>🌟🌟 <code>self</code> 会拿走当前结构体实例(调用对象)的所有权，而 <code>&amp;self</code> 却只会借用一个不可变引用，<code>&amp;mut self</code> 会借用一个可变引用</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 只填空，不要删除任何代码行!
#[derive(Debug)]
struct TrafficLight {
    color: String,
}

impl TrafficLight {
    pub fn show_state(__)  {
        println!("the current state is {}", __.color);
    }
}
fn main() {
    let light = TrafficLight{
        color: "red".to_owned(),
    };
    // 不要拿走 `light` 的所有权
    light.show_state();
    // 否则下面代码会报错
    println!("{:?}", light);
}</code></pre></pre>
<ol start="3">
<li>🌟🌟  <code>&amp;self</code> 实际上是 <code>self: &amp;Self</code> 的缩写或者说语法糖</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct TrafficLight {
    color: String,
}

impl TrafficLight {
    // 使用 `Self` 填空
    pub fn show_state(__)  {
        println!("the current state is {}", self.color);
    }

    // 填空，不要使用 `Self` 或其变体
    pub fn change_state(__) {
        self.color = "green".to_string()
    }
}
fn main() {}</code></pre></pre>
<h3 id="associated-function"><a class="header" href="#associated-function">Associated function</a></h3>
<ol start="4">
<li>🌟🌟  定义在 <code>impl</code> 语句块中的函数被称为关联函数，因为它们跟当前类型关联在一起。关联函数与方法最大的区别就是它第一个参数不是 <code>self</code> ，原因是它们不需要使用当前的实例，因此关联函数往往可以用于构造函数：初始化一个实例对象。</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct TrafficLight {
    color: String,
}

impl TrafficLight {
    // 1. 实现下面的关联函数 `new`,
    // 2. 该函数返回一个 TrafficLight 实例，包含 `color` "red"
    // 3. 该函数必须使用 `Self` 作为类型，不能在签名或者函数体中使用 `TrafficLight`
    pub fn new() 

    pub fn get_state(&amp;self) -&gt; &amp;str {
        &amp;self.color
    }
}

fn main() {
    let light = TrafficLight::new();
    assert_eq!(light.get_state(), "red");
}</code></pre></pre>
<h3 id="多个-impl-语句块"><a class="header" href="#多个-impl-语句块">多个 <code>impl</code> 语句块</a></h3>
<ol start="5">
<li>🌟 每一个结构体允许拥有多个 <code>impl</code> 语句块</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
struct Rectangle {
    width: u32,
    height: u32,
}

// 使用多个 `impl` 语句块重写下面的代码
impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}


fn main() {}</code></pre></pre>
<h3 id="enums"><a class="header" href="#enums">Enums</a></h3>
<ol start="6">
<li>🌟🌟🌟 我们还可以为枚举类型定义方法</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
#[derive(Debug)]
enum TrafficLightColor {
    Red,
    Yellow,
    Green,
}

// 为 TrafficLightColor 实现所需的方法
impl TrafficLightColor {
    
}

fn main() {
    let c = TrafficLightColor::Yellow;

    assert_eq!(c.color(), "yellow");

    println!("{:?}",c);
}</code></pre></pre>
<h2 id="practice"><a class="header" href="#practice">Practice</a></h2>
<p>@todo</p>
<blockquote>
<p>你可以在<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/method.md">这里</a>找到答案(在 solutions 路径下)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generics-and-traits"><a class="header" href="#generics-and-traits">Generics and Traits</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="泛型"><a class="header" href="#泛型">泛型</a></h1>
<h3 id="函数-1"><a class="header" href="#函数-1">函数</a></h3>
<ol>
<li>🌟🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 填空
struct A;          // 具体的类型 `A`.
struct S(A);       // 具体的类型 `S`.
struct SGen&lt;T&gt;(T); // 泛型 `SGen`.

fn reg_fn(_s: S) {}

fn gen_spec_t(_s: SGen&lt;A&gt;) {}

fn gen_spec_i32(_s: SGen&lt;i32&gt;) {}

fn generic&lt;T&gt;(_s: SGen&lt;T&gt;) {}

fn main() {
    // 使用非泛型函数
    reg_fn(__);          // 具体的类型
    gen_spec_t(__);   // 隐式地指定类型参数  `A`.
    gen_spec_i32(__); // 隐式地指定类型参数`i32`.

    // 显式地指定类型参数 `char`
    generic::&lt;char&gt;(__);

    // 隐式地指定类型参数 `char`.
    generic(__);
}</code></pre></pre>
<ol start="2">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 实现下面的泛型函数 sum
fn sum

fn main() {
    assert_eq!(5, sum(2i8, 3i8));
    assert_eq!(50, sum(20, 30));
    assert_eq!(2.46, sum(1.23, 1.23));
}</code></pre></pre>
<h3 id="结构体和-impl"><a class="header" href="#结构体和-impl">结构体和 <code>impl</code></a></h3>
<ol start="3">
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 实现一个结构体 Point 让代码工作


fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}</code></pre></pre>
<ol start="4">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 修改以下结构体让代码工作
struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    // 不要修改这行代码！
    let p = Point{x: 5, y : "hello".to_string()};
}</code></pre></pre>
<ol start="5">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 为 Val 增加泛型参数，不要修改 `main` 中的代码
struct Val {
    val: f64,
}

impl Val {
    fn value(&amp;self) -&gt; &amp;f64 {
        &amp;self.val
    }
}


fn main() {
    let x = Val{ val: 3.0 };
    let y = Val{ val: "hello".to_string()};
    println!("{}, {}", x.value(), y.value());
}</code></pre></pre>
<h3 id="方法"><a class="header" href="#方法">方法</a></h3>
<ol start="6">
<li>🌟🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

impl&lt;T, U&gt; Point&lt;T, U&gt; {
    // 实现 mixup，不要修改其它代码！
    fn mixup
}

fn main() {
    let p1 = Point { x: 5, y: 10 };
    let p2 = Point { x: "Hello", y: '中'};

    let p3 = p1.mixup(p2);

    assert_eq!(p3.x, 5);
    assert_eq!(p3.y, '中');
}</code></pre></pre>
<ol start="7">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 修复错误，让代码工作
struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl Point&lt;f32&gt; {
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}

fn main() {
    let p = Point{x: 5, y: 10};
    println!("{}",p.distance_from_origin())
}</code></pre></pre>
<blockquote>
<p>你可以在<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/generics-traits/generics.md">这里</a>找到答案(在 solutions 路径下)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="const-泛型"><a class="header" href="#const-泛型">Const 泛型</a></h1>
<p>在之前的泛型中，可以抽象为一句话：针对类型实现的泛型，所有的泛型都是为了抽象不同的类型，那有没有针对值的泛型？答案就是 <code>Const 泛型</code>。</p>
<h2 id="示例-4"><a class="header" href="#示例-4">示例</a></h2>
<ol>
<li>下面的例子同时使用泛型和 const 泛型来实现一个结构体，该结构体的字段中的数组长度是可变的</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct ArrayPair&lt;T, const N: usize&gt; {
    left: [T; N],
    right: [T; N],
}

impl&lt;T: Debug, const N: usize&gt; Debug for ArrayPair&lt;T, N&gt; {
    // ...
}</code></pre></pre>
<ol start="2">
<li>目前，const 泛型参数只能使用以下形式的实参:</li>
</ol>
<ul>
<li>一个单独的 const  泛型参数</li>
<li>一个字面量 (i.e. 整数, 布尔值或字符).</li>
<li>一个具体的 const 表达式( 表达式中不能包含任何 泛型参数)</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn foo&lt;const N: usize&gt;() {}

fn bar&lt;T, const M: usize&gt;() {
    foo::&lt;M&gt;(); // ok: 符合第一种
    foo::&lt;2021&gt;(); // ok: 符合第二种
    foo::&lt;{20 * 100 + 20 * 10 + 1}&gt;(); // ok: 符合第三种
    
    foo::&lt;{ M + 1 }&gt;(); // error: 违背第三种，const 表达式中不能有泛型参数 M
    foo::&lt;{ std::mem::size_of::&lt;T&gt;() }&gt;(); // error: 泛型表达式包含了泛型参数 T
    
    let _: [u8; M]; // ok: 符合第一种
    let _: [u8; std::mem::size_of::&lt;T&gt;()]; // error: 泛型表达式包含了泛型参数 T
}

fn main() {}</code></pre></pre>
<ol start="3">
<li>const 泛型还能帮我们避免一些运行时检查，提升性能</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2021">pub struct MinSlice&lt;T, const N: usize&gt; {
    pub head: [T; N],
    pub tail: [T],
}

fn main() {
    let slice: &amp;[u8] = b"Hello, world";
    let reference: Option&lt;&amp;u8&gt; = slice.get(6);
    // 我们知道 `.get` 返回的是 `Some(b' ')`
    // 但编译器不知道
    assert!(reference.is_some());

    let slice: &amp;[u8] = b"Hello, world";

    // 当编译构建 MinSlice 时会进行长度检查，也就是在编译期我们就知道它的长度是 12
    // 在运行期，一旦 `unwrap` 成功，在 `MinSlice` 的作用域内，就再无需任何检查    
    let minslice = MinSlice::&lt;u8, 12&gt;::from_slice(slice).unwrap();
    let value: u8 = minslice.head[6];
    assert_eq!(value, b' ')
}</code></pre></pre>
<h2 id="练习-3"><a class="header" href="#练习-3">练习</a></h2>
<ol>
<li>🌟🌟 <code>&lt;T, const N: usize&gt;</code> 是结构体类型的一部分，和数组类型一样，这意味着长度不同会导致类型不同： <code>Array&lt;i32, 3&gt;</code> 和 <code>Array&lt;i32, 4&gt;</code> 是不同的类型</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 修复错误
struct Array&lt;T, const N: usize&gt; {
    data : [T; N]
}

fn main() {
    let arrays = [
        Array{
            data: [1, 2, 3],
        },
        Array {
            data: [1.0, 2.0, 3.0],
        },
        Array {
            data: [1, 2]
        }
    ];
}</code></pre></pre>
<ol start="2">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 填空
fn print_array&lt;__&gt;(__) {
    println!("{:?}", arr);
}
fn main() {
    let arr = [1, 2, 3];
    print_array(arr);

    let arr = ["hello", "world"];
    print_array(arr);
}</code></pre></pre>
<ol start="3">
<li>🌟🌟🌟 有时我们希望能限制一个变量占用内存的大小，例如在嵌入式环境中，此时 const 泛型参数的第三种形式 <code>const 表达式</code> 就非常适合.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">#![allow(incomplete_features)]
#![feature(generic_const_exprs)]

fn check_size&lt;T&gt;(val: T)
where
    Assert&lt;{ core::mem::size_of::&lt;T&gt;() &lt; 768 }&gt;: IsTrue,
{
    //...
}

// 修复 main 函数中的错误
fn main() {
    check_size([0u8; 767]); 
    check_size([0i32; 191]);
    check_size(["hello你好"; __]); // size of &amp;str ?
    check_size([(); __].map(|_| "hello你好".to_string()));  // size of String?
    check_size(['中'; __]); // size of char ?
}



pub enum Assert&lt;const CHECK: bool&gt; {}

pub trait IsTrue {}

impl IsTrue for Assert&lt;true&gt; {}</code></pre></pre>
<blockquote>
<p>你可以在<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/generics-traits/const-generics.md">这里</a>找到答案(在 solutions 路径下)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traits"><a class="header" href="#traits">Traits</a></h1>
<p>特征 Trait 可以告诉编译器一个特定的类型所具有的、且能跟其它类型共享的特性。我们可以使用特征通过抽象的方式来定义这种共享行为，还可以使用特征约束来限定一个泛型类型必须要具有某个特定的行为。</p>
<blockquote>
<p>Note: 特征跟其它语言的接口较为类似，但是仍然有一些区别</p>
</blockquote>
<h2 id="示例-5"><a class="header" href="#示例-5">示例</a></h2>
<pre><pre class="playground"><code class="language-rust editable edition2021">
struct Sheep { naked: bool, name: String }

impl Sheep {
    fn is_naked(&amp;self) -&gt; bool {
        self.naked
    }

    fn shear(&amp;mut self) {
        if self.is_naked() {
            // `Sheep` 结构体上定义的方法可以调用 `Sheep` 所实现的特征的方法
            println!("{} is already naked...", self.name());
        } else {
            println!("{} gets a haircut!", self.name);

            self.naked = true;
        }
    }
}


trait Animal {
    // 关联函数签名；`Self` 指代实现者的类型
    // 例如我们在为 Pig 类型实现特征时，那 `new` 函数就会返回一个 `Pig` 类型的实例，这里的 `Self` 指代的就是 `Pig` 类型
    fn new(name: String) -&gt; Self;

    // 方法签名
    fn name(&amp;self) -&gt; String;
    
    fn noise(&amp;self) -&gt; String;

    // 方法还能提供默认的定义实现
    fn talk(&amp;self) {
        println!("{} says {}", self.name(), self.noise());
    }
}

impl Animal for Sheep {
    // `Self` 被替换成具体的实现者类型： `Sheep`
    fn new(name: String) -&gt; Sheep {
        Sheep { name: name, naked: false }
    }

    fn name(&amp;self) -&gt; String {
        self.name.clone()
    }

    fn noise(&amp;self) -&gt; String {
        if self.is_naked() {
            "baaaaah?".to_string()
        } else {
            "baaaaah!".to_string()
        }
    }
    
    // 默认的特征方法可以被重写
    fn talk(&amp;self) {
        println!("{} pauses briefly... {}", self.name, self.noise());
    }
}

fn main() {
    // 这里的类型注释时必须的
    let mut dolly: Sheep = Animal::new("Dolly".to_string());
    // TODO ^ 尝试去除类型注释，看看会发生什么

    dolly.talk();
    dolly.shear();
    dolly.talk();
}</code></pre></pre>
<h2 id="exercises-1"><a class="header" href="#exercises-1">Exercises</a></h2>
<ol>
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 完成两个 `impl` 语句块
// 不要修改 `main` 中的代码
trait Hello {
    fn say_hi(&amp;self) -&gt; String {
        String::from("hi")
    }

    fn say_something(&amp;self) -&gt; String;
}

struct Student {}
impl Hello for Student {
}
struct Teacher {}
impl Hello for Teacher {
}

fn main() {
    let s = Student {};
    assert_eq!(s.say_hi(), "hi");
    assert_eq!(s.say_something(), "I'm a good student");

    let t = Teacher {};
    assert_eq!(t.say_hi(), "Hi, I'm your new teacher");
    assert_eq!(t.say_something(), "I'm not a bad teacher");

    println!("Success!")
}</code></pre></pre>
<h3 id="derive-派生"><a class="header" href="#derive-派生">Derive 派生</a></h3>
<p>我们可以使用 <code>#[derive]</code> 属性来派生一些特征，对于这些特征编译器会自动进行默认实现，对于日常代码开发而言，这是非常方便的，例如大家经常用到的 <code>Debug</code> 特征，就是直接通过派生来获取默认实现，而无需我们手动去完成这个工作。</p>
<p>想要查看更多信息，可以访问<a href="https://course.rs/appendix/derive.html">这里</a>。</p>
<ol start="2">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// `Centimeters`, 一个元组结构体，可以被比较大小
#[derive(PartialEq, PartialOrd)]
struct Centimeters(f64);

// `Inches`, 一个元组结构体可以被打印
#[derive(Debug)]
struct Inches(i32);

impl Inches {
    fn to_centimeters(&amp;self) -&gt; Centimeters {
        let &amp;Inches(inches) = self;

        Centimeters(inches as f64 * 2.54)
    }
}

// 添加一些属性让代码工作
// 不要修改其它代码！
struct Seconds(i32);

fn main() {
    let _one_second = Seconds(1);

    println!("One second looks like: {:?}", _one_second);
    let _this_is_true = _one_second == _one_second;
    let _this_is_false = _one_second &gt; _one_second;

    let foot = Inches(12);

    println!("One foot equals {:?}", foot);

    let meter = Centimeters(100.0);

    let cmp =
        if foot.to_centimeters() &lt; meter {
            "smaller"
        } else {
            "bigger"
        };

    println!("One foot is {} than one meter.", cmp);
}</code></pre></pre>
<h3 id="运算符"><a class="header" href="#运算符">运算符</a></h3>
<p>在 Rust 中，许多运算符都可以被重载，事实上，运算符仅仅是特征方法调用的语法糖。例如 <code>a + b</code> 中的 <code>+</code> 是 <code>std::ops::Add</code> 特征的 <code>add</code> 方法调用，因此我们可以为自定义类型实现该特征来支持该类型的加法运算。</p>
<ol start="3">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
use std::ops;

// 实现 fn multiply 方法
// 如上所述，`+` 需要 `T` 类型实现 `std::ops::Add` 特征
// 那么, `*` 运算符需要实现什么特征呢? 你可以在这里找到答案: https://doc.rust-lang.org/core/ops/
fn multiply

fn main() {
    assert_eq!(6, multiply(2u8, 3u8));
    assert_eq!(5.0, multiply(1.0, 5.0));

    println!("Success!")
}</code></pre></pre>
<ol start="4">
<li>🌟🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 修复错误，不要修改 `main` 中的代码!
use std::ops;

struct Foo;
struct Bar;

struct FooBar;

struct BarFoo;

// 下面的代码实现了自定义类型的相加： Foo + Bar = FooBar
impl ops::Add&lt;Bar&gt; for Foo {
    type Output = FooBar;

    fn add(self, _rhs: Bar) -&gt; FooBar {
        FooBar
    }
}

impl ops::Sub&lt;Foo&gt; for Bar {
    type Output = BarFoo;

    fn sub(self, _rhs: Foo) -&gt; BarFoo {
        BarFoo
    }
}

fn main() {
    // 不要修改下面代码
    // 你需要为 FooBar 派生一些特征来让代码工作
    assert_eq!(Foo + Bar, FooBar);
    assert_eq!(Foo - Bar, BarFoo);

    println!("Success!")
}</code></pre></pre>
<h3 id="使用特征作为函数参数"><a class="header" href="#使用特征作为函数参数">使用特征作为函数参数</a></h3>
<p>除了使用具体类型来作为函数参数，我们还能通过 <code>impl Trait</code> 的方式来指定实现了该特征的参数：该参数能接受的类型必须要实现指定的特征。</p>
<ol start="5">
<li>🌟🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 实现 `fn summary` 
// 修复错误且不要移除任何代码行
trait Summary {
    fn summarize(&amp;self) -&gt; String;
}

#[derive(Debug)]
struct Post {
    title: String,
    author: String,
    content: String,
}

impl Summary for Post {
    fn summarize(&amp;self) -&gt; String {
        format!("The author of post {} is {}", self.title, self.author)
    }
}

#[derive(Debug)]
struct Weibo {
    username: String,
    content: String,
}

impl Summary for Weibo {
    fn summarize(&amp;self) -&gt; String {
        format!("{} published a weibo {}", self.username, self.content)
    }
}

fn main() {
    let post = Post {
        title: "Popular Rust".to_string(),
        author: "Sunface".to_string(),
        content: "Rust is awesome!".to_string(),
    };
    let weibo = Weibo {
        username: "sunface".to_string(),
        content: "Weibo seems to be worse than Tweet".to_string(),
    };

    summary(post);
    summary(weibo);

    println!("{:?}", post);
    println!("{:?}", weibo);
}

// 在下面实现 `fn summary` 函数
</code></pre></pre>
<h3 id="使用特征作为函数返回值"><a class="header" href="#使用特征作为函数返回值">使用特征作为函数返回值</a></h3>
<p>我们还可以在函数的返回值中使用 <code>impl Trait</code> 语法。然后只有在返回值是同一个类型时，才能这么使用，如果返回值是不同的类型，你可能更需要特征对象。</p>
<ol start="6">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
struct Sheep {}
struct Cow {}

trait Animal {
    fn noise(&amp;self) -&gt; String;
}

impl Animal for Sheep {
    fn noise(&amp;self) -&gt; String {
        "baaaaah!".to_string()
    }
}

impl Animal for Cow {
    fn noise(&amp;self) -&gt; String {
        "moooooo!".to_string()
    }
}

// 返回一个类型，该类型实现了 Animal 特征，但是我们并不能在编译期获知具体返回了哪个类型
// 修复这里的错误，你可以使用虚假的随机，也可以使用特征对象
fn random_animal(random_number: f64) -&gt; impl Animal {
    if random_number &lt; 0.5 {
        Sheep {}
    } else {
        Cow {}
    }
}

fn main() {
    let random_number = 0.234;
    let animal = random_animal(random_number);
    println!("You've randomly chosen an animal, and it says {}", animal.noise());
}</code></pre></pre>
<h3 id="特征约束"><a class="header" href="#特征约束">特征约束</a></h3>
<p><code>impl Trait</code> 语法非常直观简洁，但它实际上是特征约束的语法糖。</p>
<p>当使用泛型参数时，我们往往需要为该参数指定特定的行为，这种指定方式就是通过特征约束来实现的。</p>
<ol start="7">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    assert_eq!(sum(1, 2), 3);
}

// 通过两种方法使用特征约束来实现 `fn sum`
fn sum&lt;T&gt;(x: T, y: T) -&gt; T {
    x + y
}</code></pre></pre>
<ol start="8">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 修复代码中的错误
struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self {
            x,
            y,
        }
    }
}

impl&lt;T: std::fmt::Debug + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!("The largest member is x = {:?}", self.x);
        } else {
            println!("The largest member is y = {:?}", self.y);
        }
    }
}

struct Unit(i32);

fn main() {
    let pair = Pair{
        x: Unit(1),
        y: Unit(3)
    };

    pair.cmp_display();
}</code></pre></pre>
<ol start="9">
<li>🌟🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 填空
fn example1() {
    // `T: Trait` 是最常使用的方式
    // `T: Fn(u32) -&gt; u32` 说明 `T` 只能接收闭包类型的参数
    struct Cacher&lt;T: Fn(u32) -&gt; u32&gt; {
        calculation: T,
        value: Option&lt;u32&gt;,
    }

    impl&lt;T: Fn(u32) -&gt; u32&gt; Cacher&lt;T&gt; {
        fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
            Cacher {
                calculation,
                value: None,
            }
        }

        fn value(&amp;mut self, arg: u32) -&gt; u32 {
            match self.value {
                Some(v) =&gt; v,
                None =&gt; {
                    let v = (self.calculation)(arg);
                    self.value = Some(v);
                    v
                },
            }
        }
    }

    let mut cacher = Cacher::new(|x| x+1);
    assert_eq!(cacher.value(10), __);
    assert_eq!(cacher.value(15), __);
}


fn example2() {
    // 还可以使用 `where` 来约束 T
    struct Cacher&lt;T&gt;
        where T: Fn(u32) -&gt; u32,
    {
        calculation: T,
        value: Option&lt;u32&gt;,
    }

    impl&lt;T&gt; Cacher&lt;T&gt;
        where T: Fn(u32) -&gt; u32,
    {
        fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
            Cacher {
                calculation,
                value: None,
            }
        }

        fn value(&amp;mut self, arg: u32) -&gt; u32 {
            match self.value {
                Some(v) =&gt; v,
                None =&gt; {
                    let v = (self.calculation)(arg);
                    self.value = Some(v);
                    v
                },
            }
        }
    }

    let mut cacher = Cacher::new(|x| x+1);
    assert_eq!(cacher.value(20), __);
    assert_eq!(cacher.value(25), __);
}



fn main() {
    example1();
    example2();

    println!("Success!")
}</code></pre></pre>
<blockquote>
<p>你可以在<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/generics-traits/traits.md">这里</a>找到答案(在 solutions 路径下)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="特征对象"><a class="header" href="#特征对象">特征对象</a></h1>
<p>在<a href="https://practice.rs/generics-traits/traits.html#returning-types-that-implement-traits">特征练习中</a> 我们已经知道当函数返回多个类型时，<code>impl Trait</code> 是无法使用的。</p>
<p>对于数组而言，其中一个限制就是无法存储不同类型的元素，但是通过之前的学习，大家应该知道枚举可以在部分场景解决这种问题，但是这种方法局限性较大。此时就需要我们的主角登场了。</p>
<h2 id="使用-dyn-返回特征"><a class="header" href="#使用-dyn-返回特征">使用 <code>dyn</code> 返回特征</a></h2>
<p>Rust 编译器需要知道一个函数的返回类型占用多少内存空间。由于特征的不同实现类型可能会占用不同的内存，因此通过 <code>impl Trait</code> 返回多个类型是不被允许的，但是我们可以返回一个 <code>dyn</code> 特征对象来解决问题。</p>
<ol>
<li>🌟🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
trait Bird {
    fn quack(&amp;self) -&gt; String;
}

struct Duck;
impl Duck {
    fn swim(&amp;self) {
        println!("Look, the duck is swimming")
    }
}
struct Swan;
impl Swan {
    fn fly(&amp;self) {
        println!("Look, the duck.. oh sorry, the swan is flying")
    }
}

impl Bird for Duck {
    fn quack(&amp;self) -&gt; String{
        "duck duck".to_string()
    }
}

impl Bird for Swan {
    fn quack(&amp;self) -&gt; String{
        "swan swan".to_string()
    }
}

fn main() {
    // 填空
    let duck = __;
    duck.swim();

    let bird = hatch_a_bird(2);
    // 变成鸟儿后，它忘记了如何游，因此以下代码会报错
    // bird.swim();
    // 但它依然可以叫唤
    assert_eq!(bird.quack(), "duck duck");

    let bird = hatch_a_bird(1);
    // 这只鸟儿忘了如何飞翔，因此以下代码会报错
    // bird.fly();
    // 但它也可以叫唤
    assert_eq!(bird.quack(), "swan swan");

    println!("Success!")
}   

// 实现以下函数
fn hatch_a_bird...
</code></pre></pre>
<h2 id="在数组中使用特征对象"><a class="header" href="#在数组中使用特征对象">在数组中使用特征对象</a></h2>
<ol start="2">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">trait Bird {
    fn quack(&amp;self);
}

struct Duck;
impl Duck {
    fn fly(&amp;self) {
        println!("Look, the duck is flying")
    }
}
struct Swan;
impl Swan {
    fn fly(&amp;self) {
        println!("Look, the duck.. oh sorry, the swan is flying")
    }
}

impl Bird for Duck {
    fn quack(&amp;self) {
        println!("{}", "duck duck");
    }
}

impl Bird for Swan {
    fn quack(&amp;self) {
        println!("{}", "swan swan");
    }
}

fn main() {
    // 填空
    let birds __;

    for bird in birds {
        bird.quack();
        // 当 duck 和 swan 变成 bird 后，它们都忘了如何翱翔于天际，只记得该怎么叫唤了。。
        // 因此，以下代码会报错
        // bird.fly();
    }
}</code></pre></pre>
<h2 id="dyn-and-boxdyn"><a class="header" href="#dyn-and-boxdyn"><code>&amp;dyn</code> and <code>Box&lt;dyn&gt;</code></a></h2>
<ol start="3">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 填空
trait Draw {
    fn draw(&amp;self) -&gt; String;
}

impl Draw for u8 {
    fn draw(&amp;self) -&gt; String {
        format!("u8: {}", *self)
    }
}

impl Draw for f64 {
    fn draw(&amp;self) -&gt; String {
        format!("f64: {}", *self)
    }
}

fn main() {
    let x = 1.1f64;
    let y = 8u8;

    // draw x
    draw_with_box(__);

    // draw y
    draw_with_ref(&amp;y);

    println!("Success!")
}

fn draw_with_box(x: Box&lt;dyn Draw&gt;) {
    x.draw();
}

fn draw_with_ref(x: __) {
    x.draw();
}</code></pre></pre>
<h2 id="静态分发和动态分发static-and-dynamic-dispatch"><a class="header" href="#静态分发和动态分发static-and-dynamic-dispatch">静态分发和动态分发Static and Dynamic dispatch</a></h2>
<p>关于这块内容的解析介绍，请参见 <a href="https://course.rs/basic/trait/trait-object.html#%E7%89%B9%E5%BE%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%86%E5%8F%91">Rust语言圣经</a>。</p>
<ol start="4">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
trait Foo {
    fn method(&amp;self) -&gt; String;
}

impl Foo for u8 {
    fn method(&amp;self) -&gt; String { format!("u8: {}", *self) }
}

impl Foo for String {
    fn method(&amp;self) -&gt; String { format!("string: {}", *self) }
}

// 通过泛型实现以下函数
fn static_dispatch...

// 通过特征对象实现以下函数
fn dynamic_dispatch...

fn main() {
    let x = 5u8;
    let y = "Hello".to_string();

    static_dispatch(x);
    dynamic_dispatch(&amp;y);

    println!("Success!")
}</code></pre></pre>
<h2 id="对象安全"><a class="header" href="#对象安全">对象安全</a></h2>
<p>一个特征能变成特征对象，首先该特征必须是对象安全的，即该特征的所有方法都必须拥有以下特点：</p>
<ul>
<li>返回类型不能是 <code>Self</code>.</li>
<li>不能使用泛型参数</li>
</ul>
<ol start="5">
<li>🌟🌟🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 使用至少两种方法让代码工作
// 不要添加/删除任何代码行
trait MyTrait {
    fn f(&amp;self) -&gt; Self;
}

impl MyTrait for u32 {
    fn f(&amp;self) -&gt; Self { 42 }
}

impl MyTrait for String {
    fn f(&amp;self) -&gt; Self { self.clone() }
}

fn my_function(x: Box&lt;dyn MyTrait&gt;)  {
    x.f()
}

fn main() {
    my_function(Box::new(13_u32));
    my_function(Box::new(String::from("abc")));

    println!("Success!")
}</code></pre></pre>
<blockquote>
<p>你可以在<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/generics-traits/trait-object.md">这里</a>找到答案(在 solutions 路径下)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="进一步深入特征"><a class="header" href="#进一步深入特征">进一步深入特征</a></h1>
<h2 id="关联类型"><a class="header" href="#关联类型">关联类型</a></h2>
<p>关联类型主要用于提升代码的可读性，例如以下代码 :</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait CacheableItem: Clone + Default + fmt::Debug + Decodable + Encodable {
  type Address: AsRef&lt;[u8]&gt; + Clone + fmt::Debug + Eq + Hash;
  fn is_null(&amp;self) -&gt; bool;
}
<span class="boring">}</span></code></pre></pre>
<p>相比 <code>AsRef&lt;[u8]&gt; + Clone + fmt::Debug + Eq + Hash</code>， <code>Address</code> 的使用可以极大的减少其它类型在实现该特征时所需的模版代码.</p>
<ol>
<li>🌟🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
struct Container(i32, i32);

// 使用关联类型实现重新实现以下特征
// trait Contains {
//    type A;
//    type B;

trait Contains&lt;A, B&gt; {
    fn contains(&amp;self, _: &amp;A, _: &amp;B) -&gt; bool;
    fn first(&amp;self) -&gt; i32;
    fn last(&amp;self) -&gt; i32;
}

impl Contains&lt;i32, i32&gt; for Container {
    fn contains(&amp;self, number_1: &amp;i32, number_2: &amp;i32) -&gt; bool {
        (&amp;self.0 == number_1) &amp;&amp; (&amp;self.1 == number_2)
    }
    // Grab the first number.
    fn first(&amp;self) -&gt; i32 { self.0 }

    // Grab the last number.
    fn last(&amp;self) -&gt; i32 { self.1 }
}

fn difference&lt;A, B, C: Contains&lt;A, B&gt;&gt;(container: &amp;C) -&gt; i32 {
    container.last() - container.first()
}

fn main() {
    let number_1 = 3;
    let number_2 = 10;

    let container = Container(number_1, number_2);

    println!("Does container contain {} and {}: {}",
        &amp;number_1, &amp;number_2,
        container.contains(&amp;number_1, &amp;number_2));
    println!("First number: {}", container.first());
    println!("Last number: {}", container.last());
    
    println!("The difference is: {}", difference(&amp;container));
}</code></pre></pre>
<h2 id="定义默认的泛型类型参数"><a class="header" href="#定义默认的泛型类型参数">定义默认的泛型类型参数</a></h2>
<p>当我们使用泛型类型参数时，可以为该泛型参数指定一个具体的默认类型，这样当实现该特征时，如果该默认类型可以使用，那用户再无需手动指定具体的类型。</p>
<ol start="2">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
use std::ops::Sub;

#[derive(Debug, PartialEq)]
struct Point&lt;T&gt; {
    x: T,
    y: T,
}

// 用三种方法填空: 其中两种使用默认的泛型参数，另外一种不使用
impl __ {
    type Output = Self;

    fn sub(self, other: Self) -&gt; Self::Output {
        Point {
            x: self.x - other.x,
            y: self.y - other.y,
        }
    }
}

fn main() {
    assert_eq!(Point { x: 2, y: 3 } - Point { x: 1, y: 0 },
        Point { x: 1, y: 3 });

    println!("Success!")
}</code></pre></pre>
<h2 id="完全限定语法"><a class="header" href="#完全限定语法">完全限定语法</a></h2>
<p>在 Rust 中，两个不同特征的方法完全可以同名，且你可以为同一个类型同时实现这两个特征。这种情况下，就出现了一个问题：该如何调用这两个特征上定义的同名方法。为了解决这个问题，我们需要使用完全限定语法( Fully Qualified Syntax )。</p>
<h4 id="示例-6"><a class="header" href="#示例-6">示例</a></h4>
<pre><pre class="playground"><code class="language-rust editable edition2021">trait UsernameWidget {
    fn get(&amp;self) -&gt; String;
}

trait AgeWidget {
    fn get(&amp;self) -&gt; u8;
}

struct Form {
    username: String,
    age: u8,
}

impl UsernameWidget for Form {
    fn get(&amp;self) -&gt; String {
        self.username.clone()
    }
}

impl AgeWidget for Form {
    fn get(&amp;self) -&gt; u8 {
        self.age
    }
}

fn main() {
    let form = Form{
        username: "rustacean".to_owned(),
        age: 28,
    };

    // 如果你反注释下面一行代码，将看到一个错误: Fully Qualified Syntax
    // 毕竟，这里有好几个同名的 `get` 方法
    // 
    // println!("{}", form.get());
    
    let username = UsernameWidget::get(&amp;form);
    assert_eq!("rustacean".to_owned(), username);
    let age = AgeWidget::get(&amp;form); // 你还可以使用以下语法 `&lt;Form as AgeWidget&gt;::get`
    assert_eq!(28, age);

    println!("Success!")
}</code></pre></pre>
<h4 id="练习题"><a class="header" href="#练习题">练习题</a></h4>
<ol start="3">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">trait Pilot {
    fn fly(&amp;self) -&gt; String;
}

trait Wizard {
    fn fly(&amp;self) -&gt; String;
}

struct Human;

impl Pilot for Human {
    fn fly(&amp;self) -&gt; String {
        String::from("This is your captain speaking.")
    }
}

impl Wizard for Human {
    fn fly(&amp;self) -&gt; String {
        String::from("Up!")
    }
}

impl Human {
    fn fly(&amp;self) -&gt; String {
        String::from("*waving arms furiously*")
    }
}

fn main() {
    let person = Human;

    assert_eq!(__, "This is your captain speaking.");
    assert_eq!(__, "Up!");

    assert_eq!(__, "*waving arms furiously*");

    println!("Success!")
}</code></pre></pre>
<h2 id="supertraits"><a class="header" href="#supertraits">Supertraits</a></h2>
<p>有些时候我们希望在特征上实现类似继承的特性，例如让一个特征 <code>A</code> 使用另一个特征 <code>B</code> 的功能。这种情况下，一个类型要实现特征 <code>A</code> 首先要实现特征 <code>B</code>， 特征 <code>B</code> 就被称为 <code>supertrait</code></p>
<ol start="4">
<li>🌟🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
trait Person {
    fn name(&amp;self) -&gt; String;
}

// Person 是 Student 的 supertrait .
// 实现 Student 需要同时实现 Person.
trait Student: Person {
    fn university(&amp;self) -&gt; String;
}

trait Programmer {
    fn fav_language(&amp;self) -&gt; String;
}

// CompSciStudent (computer science student) 是 Programmer 
// 和 Student 的 subtrait. 实现 CompSciStudent 需要先实现这两个 supertraits.
trait CompSciStudent: Programmer + Student {
    fn git_username(&amp;self) -&gt; String;
}

fn comp_sci_student_greeting(student: &amp;dyn CompSciStudent) -&gt; String {
    format!(
        "My name is {} and I attend {}. My favorite language is {}. My Git username is {}",
        student.name(),
        student.university(),
        student.fav_language(),
        student.git_username()
    )
}

struct CSStudent {
    name: String,
    university: String,
    fav_language: String,
    git_username: String
}

// 为 CSStudent 实现所需的特征
impl ...

fn main() {
    let student = CSStudent {
        name: "Sunfei".to_string(),
        university: "XXX".to_string(),
        fav_language: "Rust".to_string(),
        git_username: "sunface".to_string()
    };

    // 填空
    println!("{}", comp_sci_student_greeting(__));
}</code></pre></pre>
<h2 id="孤儿原则"><a class="header" href="#孤儿原则">孤儿原则</a></h2>
<p>关于孤儿原则的详细介绍请参见<a href="https://course.rs/basic/trait/trait#%E7%89%B9%E5%BE%81%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%AD%A4%E5%84%BF%E8%A7%84%E5%88%99">特征定义与实现的位置孤儿规则</a> 和 <a href="https://course.rs/basic/trait/advance-trait.html#%E5%9C%A8%E5%A4%96%E9%83%A8%E7%B1%BB%E5%9E%8B%E4%B8%8A%E5%AE%9E%E7%8E%B0%E5%A4%96%E9%83%A8%E7%89%B9%E5%BE%81newtype">在外部类型上实现外部特征</a>。</p>
<ol start="5">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::fmt;

// 定义一个 newtype `Pretty`


impl fmt::Display for Pretty {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "\"{}\"", self.0.clone() + ", world")
    }
}

fn main() {
    let w = Pretty("hello".to_string());
    println!("w = {}", w);
}</code></pre></pre>
<blockquote>
<p>你可以在<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/generics-traits/advanced-trait.md">这里</a>找到答案(在 solutions 路径下)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="集合类型"><a class="header" href="#集合类型">集合类型</a></h1>
<p>学习资源:</p>
<ul>
<li>简体中文: <a href="https://course.rs/basic/collections/intro.html">Rust语言圣经 - 集合类型</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string-1"><a class="header" href="#string-1">String</a></h1>
<p><code>std::string::String</code> 是 UTF-8 编码、可增长的动态字符串. 它也是我们日常开发中最常用的字符串类型，同时对于它所拥有的内容拥有所有权。</p>
<h3 id="基本操作"><a class="header" href="#基本操作">基本操作</a></h3>
<ol>
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 填空并修复错误
// 1. 不要使用 `to_string()`
// 2. 不要添加/删除任何代码行
fn main() {
    let mut s: String = "hello, ";
    s.push_str("world".to_string());
    s.push(__);

    move_ownership(s);

    assert_eq!(s, "hello, world!");

    println!("Success!")
}

fn move_ownership(s: String) {
    println!("ownership of \"{}\" is moved here!", s)
}</code></pre></pre>
<h3 id="string-and-str"><a class="header" href="#string-and-str">String and &amp;str</a></h3>
<p>虽然 <code>String</code> 的底层是 <code>Vec&lt;u8&gt;</code> 也就是字节数组的形式存储的，但是它是基于 UTF-8 编码的字符序列。<code>String</code> 分配在堆上、可增长且不是以 <code>null</code> 结尾。</p>
<p>而 <code>&amp;str</code> 是<a href="https://course.rs/confonding/slice.html">切片引用</a>类型( <code>&amp;[u8]</code> )，指向一个合法的 UTF-8 字符序列，总之，<code>&amp;str</code> 和 <code>String</code> 的关系类似于 <code>&amp;[T]</code> 和 <code>Vec&lt;T&gt;</code> 。</p>
<p>如果大家想了解更多，可以看看<a href="https://course.rs/difficulties/string.html">易混淆概念解析 - &amp;str 和 String</a>。</p>
<ol start="2">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 填空
fn main() {  
   let mut s = String::from("hello, world");

   let slice1: &amp;str = __; // 使用两种方法
   assert_eq!(slice1, "hello, world");

   let slice2 = __;
   assert_eq!(slice2, "hello");

   let slice3: __ = __; 
   slice3.push('!');
   assert_eq!(slice3, "hello, world!");

   println!("Success!")
}</code></pre></pre>
<ol start="3">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 问题:  我们的代码中发生了多少次堆内存分配？
// 你的回答: 
fn main() {  
    // 基于 `&amp;str` 类型创建一个 String,
    // 字符串字面量的类型是 `&amp;str`
   let s: String = String::from("hello, world!");

   // 创建一个切片引用指向 String `s`
   let slice: &amp;str = &amp;s;

   // 基于刚创建的切片来创建一个 String
   let s: String = slice.to_string();

   assert_eq!(s, "hello, world!");

   println!("Success!")
}</code></pre></pre>
<h3 id="utf-8--索引"><a class="header" href="#utf-8--索引">UTF-8 &amp; 索引</a></h3>
<p>由于 String 都是 UTF-8 编码的，这会带来几个影响:</p>
<ul>
<li>如果你需要的是非 UTF-8 字符串，可以考虑 <a href="https://doc.rust-lang.org/stable/std/ffi/struct.OsString.html">OsString</a></li>
<li>无法通过索引的方式访问一个 String</li>
</ul>
<p>具体请看<a href="https://course.rs/basic/compound-type/string-slice.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B4%A2%E5%BC%95">字符串索引</a>。</p>
<ol start="4">
<li>🌟🌟🌟 我们无法通过索引的方式访问字符串中的某个字符，但是可以通过切片的方式来获取字符串的某一部分 <code>&amp;s1[start..end]</code></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 填空并修复错误
fn main() {
    let s = String::from("hello, 世界");
    let slice1 = s[0]; //提示: `h` 在 UTF-8 编码中只占用 1 个字节
    assert_eq!(slice1, "h");

    let slice2 = &amp;s[3..5];// 提示: `世` 在 UTF-8 编码中占用 3 个字节
    assert_eq!(slice2, "世");
    
    // 迭代 s 中的所有字符
    for (i, c) in s.__ {
        if i == 7 {
            assert_eq!(c, '世')
        }
    }

    println!("Success!")
}</code></pre></pre>
<h4 id="utf8_slice-1"><a class="header" href="#utf8_slice-1">utf8_slice</a></h4>
<p>我们可以使用 <a href="https://docs.rs/utf8_slice/1.0.0/utf8_slice/fn.slice.html">utf8_slice</a> 来按照字符的自然索引方式对 UTF-8 字符串进行切片访问，与之前的切片方式相比，它索引的是字符，而之前的方式索引的是字节.</p>
<p><strong>示例</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021">use utf8_slice;
fn main() {
   let s = "The 🚀 goes to the 🌑!";

   let rocket = utf8_slice::slice(s, 4, 5);
   // Will equal "🚀"
}</code></pre></pre>
<ol start="5">
<li>🌟🌟🌟</li>
</ol>
<blockquote>
<p>提示: 也许你需要使用 <code>from_utf8</code> 方法</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 填空
fn main() {
    let mut s = String::new();
    __;

    let v = vec![104, 101, 108, 108, 111];

    // 将字节数组转换成 String
    let s1 = __;
    
    
    assert_eq!(s, s1);

    println!("Success!")
}</code></pre></pre>
<h3 id="内部表示"><a class="header" href="#内部表示">内部表示</a></h3>
<p>事实上 <code>String</code> 是一个智能指针，它作为一个结构体存储在栈上，然后指向存储在堆上的字符串底层数据。</p>
<p>存储在栈上的智能指针结构体由三部分组成：一个指针只指向堆上的字节数组，已使用的长度以及已分配的容量 capacity (已使用的长度小于等于已分配的容量，当容量不够时，会重新分配内存空间)。</p>
<ol start="6">
<li>🌟🌟 如果 String 的当前容量足够，那么添加字符将不会导致新的内存分配</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 修改下面的代码以打印如下内容: 
// 25
// 25
// 25
// 循环中不会发生任何内存分配
fn main() {
    let mut s = String::new();

    println!("{}", s.capacity());

    for _ in 0..2 {
        s.push_str("hello");
        println!("{}", s.capacity());
    }

    println!("Success!")
}</code></pre></pre>
<ol start="7">
<li>🌟🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 填空
use std::mem;

fn main() {
    let story = String::from("Rust By Practice");

    // 阻止 String 的数据被自动 drop
    let mut story = mem::ManuallyDrop::new(story);

    let ptr = story.__();
    let len = story.__();
    let capacity = story.__();

    assert_eq!(16, len);

    // 我们可以基于 ptr 指针、长度和容量来重新构建 String. 
    // 这种操作必须标记为 unsafe，因为我们需要自己来确保这里的操作是安全的
    let s = unsafe { String::from_raw_parts(ptr, len, capacity) };

    assert_eq!(*story, s);

    println!("Success!")
}</code></pre></pre>
<h3 id="常用方法todo"><a class="header" href="#常用方法todo">常用方法(TODO)</a></h3>
<p>关于 String 的常用方法练习，可以查看<a href="collections/../std/String.html">这里</a>.</p>
<blockquote>
<p>你可以在<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/collections/String.md">这里</a>找到答案(在 solutions 路径下)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vector"><a class="header" href="#vector">Vector</a></h1>
<p>相比 <code>[T; N]</code> 形式的数组， <code>Vector</code> 最大的特点就是可以动态调整长度。</p>
<h3 id="基本操作-1"><a class="header" href="#基本操作-1">基本操作</a></h3>
<ol>
<li>🌟🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let arr: [u8; 3] = [1, 2, 3];
    
    let v = Vec::from(arr);
    is_vec(v);

    let v = vec![1, 2, 3];
    is_vec(v);

    // vec!(..) 和 vec![..] 是同样的宏，宏可以使用 []、()、{}三种形式，因此...
    let v = vec!(1, 2, 3);
    is_vec(v);
    
    // ...在下面的代码中, v 是 Vec&lt;[u8; 3]&gt; , 而不是 Vec&lt;u8&gt;
    // 使用 Vec::new 和 `for` 来重写下面这段代码
    let v1 = vec!(arr);
    is_vec(v1);
 
    assert_eq!(v, v1);

    println!("Success!")
}

fn is_vec(v: Vec&lt;u8&gt;) {}</code></pre></pre>
<ol start="2">
<li>🌟🌟 <code>Vec</code> 可以使用 <code>extend</code> 方法进行扩展</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 填空
fn main() {
    let mut v1 = Vec::from([1, 2, 4]);
    v1.pop();
    v1.push(3);
    
    let mut v2 = Vec::new();
    v2.__;

    assert_eq!(v1, v2);

    println!("Success!")
}</code></pre></pre>
<h3 id="将-x-类型转换frominto-特征成-vec"><a class="header" href="#将-x-类型转换frominto-特征成-vec">将 X 类型转换(From/Into 特征)成 Vec</a></h3>
<p>只要为 <code>Vec</code> 实现了 <code>From&lt;T&gt;</code> 特征，那么 <code>T</code> 就可以被转换成 <code>Vec</code>。</p>
<ol start="3">
<li>🌟🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 填空
fn main() {
    // array -&gt; Vec
    // impl From&lt;[T; N]&gt; for Vec
    let arr = [1, 2, 3];
    let v1 = __(arr);
    let v2: Vec&lt;i32&gt; = arr.__();
 
    assert_eq!(v1, v2);
 
    
    // String -&gt; Vec
    // impl From&lt;String&gt; for Vec
    let s = "hello".to_string();
    let v1: Vec&lt;u8&gt; = s.__();

    let s = "hello".to_string();
    let v2 = s.into_bytes();
    assert_eq!(v1, v2);

    // impl&lt;'_&gt; From&lt;&amp;'_ str&gt; for Vec
    let s = "hello";
    let v3 = Vec::__(s);
    assert_eq!(v2, v3);

    // 迭代器 Iterators 可以通过 collect 变成 Vec
    let v4: Vec&lt;i32&gt; = [0; 10].into_iter().collect();
    assert_eq!(v4, vec![0; 10]);

    println!("Success!")
 }</code></pre></pre>
<h3 id="索引"><a class="header" href="#索引">索引</a></h3>
<ol start="4">
<li>🌟🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 修复错误并实现缺失的代码
fn main() {
    let mut v = Vec::from([1, 2, 3]);
    for i in 0..5 {
        println!("{:?}", v[i])
    }

    for i in 0..5 {
       // 实现这里的代码...
    }
    
    assert_eq!(v, vec![2, 3, 4, 5, 6]);

    println!("Success!")
}</code></pre></pre>
<h3 id="切片"><a class="header" href="#切片">切片</a></h3>
<p>与 <code>String</code> 的切片类似， <code>Vec</code> 也可以使用切片。如果说 <code>Vec</code> 是可变的，那它的切片就是不可变或者说只读的，我们可以通过 <code>&amp;</code> 来获取切片。</p>
<p>在 Rust 中，将切片作为参数进行传递是更常见的使用方式，例如当一个函数只需要可读性时，那传递 <code>Vec</code> 或 <code>String</code> 的切片 <code>&amp;[T]</code> / <code>&amp;str</code> 会更加适合。</p>
<ol start="5">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 修复错误
fn main() {
    let mut v = vec![1, 2, 3];

    let slice1 = &amp;v[..];
    // 越界访问将导致 panic.
    // 修改时必须使用 `v.len`
    let slice2 = &amp;v[0..4];
    
    assert_eq!(slice1, slice2);
    
    // 切片是只读的
    // 注意：切片和 `&amp;Vec` 是不同的类型，后者仅仅是 `Vec` 的引用，并可以通过解引用直接获取 `Vec`
    let vec_ref: &amp;mut Vec&lt;i32&gt; = &amp;mut v;
    (*vec_ref).push(4);
    let slice3 = &amp;mut v[0..3];
    slice3.push(4);

    assert_eq!(slice3, &amp;[1, 2, 3, 4]);

    println!("Success!")
}</code></pre></pre>
<h3 id="容量"><a class="header" href="#容量">容量</a></h3>
<p>容量 <code>capacity</code> 是已经分配好的内存空间，用于存储未来添加到 <code>Vec</code> 中的元素。而长度 <code>len</code> 则是当前 <code>Vec</code> 中已经存储的元素数量。如果要添加新元素时，长度将要超过已有的容量，那容量会自动进行增长：Rust 会重新分配一块更大的内存空间，然后将之前的 <code>Vec</code> 拷贝过去，因此，这里就会发生新的内存分配( 目前 Rust 的容量调整策略是加倍，例如 2 -&gt; 4 -&gt; 8 ..)。</p>
<p>若这段代码会频繁发生，那频繁的内存分配会大幅影响我们系统的性能，最好的办法就是提前分配好足够的容量，尽量减少内存分配。</p>
<ol start="6">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 修复错误
fn main() {
    let mut vec = Vec::with_capacity(10);

    assert_eq!(vec.len(), __);
    assert_eq!(vec.capacity(), 10);

    // 由于提前设置了足够的容量，这里的循环不会造成任何内存分配...
    for i in 0..10 {
        vec.push(i);
    }
    assert_eq!(vec.len(), __);
    assert_eq!(vec.capacity(), __);

    // ...但是下面的代码会造成新的内存分配
    vec.push(11);
    assert_eq!(vec.len(), 11);
    assert!(vec.capacity() &gt;= 11);


    // 填写一个合适的值，在 `for` 循环运行的过程中，不会造成任何内存分配
    let mut vec = Vec::with_capacity(__);
    for i in 0..100 {
        vec.push(i);
    }

    assert_eq!(vec.len(), __);
    assert_eq!(vec.capacity(), __);
    
    println!("Success!")
}</code></pre></pre>
<h3 id="在-vec-中存储不同类型的元素"><a class="header" href="#在-vec-中存储不同类型的元素">在 Vec 中存储不同类型的元素</a></h3>
<p><code>Vec</code> 中的元素必须是相同的类型，例如以下代码会发生错误:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
   let v = vec![1, 2.0, 3];
}</code></pre></pre>
<p>但是我们可以使用枚举或特征对象来存储不同的类型.</p>
<ol start="7">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
enum IpAddr {
    V4(String),
    V6(String),
}
fn main() {
    // 填空
    let v : Vec&lt;IpAddr&gt;= __;
    
    // 枚举的比较需要派生 PartialEq 特征
    assert_eq!(v[0], IpAddr::V4("127.0.0.1".to_string()));
    assert_eq!(v[1], IpAddr::V6("::1".to_string()));

    println!("Success!")
}</code></pre></pre>
<ol start="8">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">trait IpAddr {
    fn display(&amp;self);
}

struct V4(String);
impl IpAddr for V4 {
    fn display(&amp;self) {
        println!("ipv4: {:?}",self.0)
    }
}
struct V6(String);
impl IpAddr for V6 {
    fn display(&amp;self) {
        println!("ipv6: {:?}",self.0)
    }
}

fn main() {
    // 填空
    let v: __= vec![
        Box::new(V4("127.0.0.1".to_string())),
        Box::new(V6("::1".to_string())),
    ];

    for ip in v {
        ip.display();
    }
}</code></pre></pre>
<blockquote>
<p>你可以在<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/collections/Vector.md">这里</a>找到答案(在 solutions 路径下)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashmap"><a class="header" href="#hashmap">HashMap</a></h1>
<p><code>HashMap</code> 默认使用 <code>SipHash 1-3</code> 哈希算法，该算法对于抵抗 <code>HashDos</code> 攻击非常有效。在性能方面，如果你的 key 是中型大小的，那该算法非常不错，但是如果是小型的 key( 例如整数 )亦或是大型的 key ( 例如字符串 )，那你需要采用社区提供的其它算法来提高性能。</p>
<p>哈希表的算法是基于 Google 的 <a href="https://abseil.io/blog/20180927-swisstables">SwissTable</a>，你可以在<a href="https://github.com/abseil/abseil-cpp/blob/master/absl/container/internal/raw_hash_set.h">这里</a>找到 C++ 的实现，同时在 <a href="https://www.youtube.com/watch?v=ncHmEUmJZf4">CppCon talk</a> 上也有关于算法如何工作的演讲。</p>
<h3 id="基本操作-2"><a class="header" href="#基本操作-2">基本操作</a></h3>
<ol>
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 填空并修复错误
use std::collections::HashMap;
fn main() {
    let mut scores = HashMap::new();
    scores.insert("Sunface", 98);
    scores.insert("Daniel", 95);
    scores.insert("Ashley", 69.0);
    scores.insert("Katie", "58");

    // get 返回一个 Option&lt;&amp;V&gt; 枚举值
    let score = scores.get("Sunface");
    assert_eq!(score, Some(98));

    if scores.contains_key("Daniel") {
        // 索引返回一个值 V
        let score = scores["Daniel"];
        assert_eq!(score, __);
        scores.remove("Daniel");
    }

    assert_eq!(scores.len(), __);

    for (name, score) in scores {
        println!("The score of {} is {}", name, score)
    }
}</code></pre></pre>
<ol start="2">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
use std::collections::HashMap;
fn main() {
    let teams = [
        ("Chinese Team", 100),
        ("American Team", 10),
        ("France Team", 50),
    ];

    let mut teams_map1 = HashMap::new();
    for team in &amp;teams {
        teams_map1.insert(team.0, team.1);
    }

    // 使用两种方法实现 team_map2
    // 提示:其中一种方法是使用 `collect` 方法
    let teams_map2...

    assert_eq!(teams_map1, teams_map2);

    println!("Success!")
}</code></pre></pre>
<ol start="3">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 填空
use std::collections::HashMap;
fn main() {
    // 编译器可以根据后续的使用情况帮我自动推断出 HashMap 的类型，当然你也可以显式地标注类型：HashMap&lt;&amp;str, u8&gt;
    let mut player_stats = HashMap::new();

    // 查询指定的 key, 若不存在时，则插入新的 kv 值
    player_stats.entry("health").or_insert(100);

    assert_eq!(player_stats["health"], __);

    // 通过函数来返回新的值
    player_stats.entry("health").or_insert_with(random_stat_buff);
    assert_eq!(player_stats["health"], __);

    let health = player_stats.entry("health").or_insert(50);
    assert_eq!(health, __);
    *health -= 50;
    assert_eq!(*health, __);

    println!("Success!")
}

fn random_stat_buff() -&gt; u8 {
    // 为了简单，我们没有使用随机，而是返回一个固定的值
    42
}</code></pre></pre>
<h3 id="hashmap-key-的限制"><a class="header" href="#hashmap-key-的限制">HashMap key 的限制</a></h3>
<p>任何实现了 <code>Eq</code> 和 <code>Hash</code> 特征的类型都可以用于 <code>HashMap</code> 的 key，包括:</p>
<ul>
<li><code>bool</code> (虽然很少用到，因为它只能表达两种 key)</li>
<li><code>int</code>, <code>uint</code> 以及它们的变体，例如 <code>u8</code>、<code>i32</code> 等</li>
<li><code>String</code> 和 <code>&amp;str</code> (提示: <code>HashMap</code> 的 key 是 <code>String</code> 类型时，你其实可以使用 <code>&amp;str</code> 配合 <code>get</code> 方法进行查询</li>
</ul>
<p>需要注意的是，<code>f32</code> 和 <code>f64</code> 并没有实现 <code>Hash</code>，原因是 <a href="https://en.wikipedia.org/wiki/Floating-point_arithmetic#Accuracy_problems">浮点数精度</a> 的问题会导致它们无法进行相等比较。</p>
<p>如果一个集合类型的所有字段都实现了 <code>Eq</code> 和 <code>Hash</code>,那该集合类型会自动实现 <code>Eq</code> 和 <code>Hash</code>。例如 <code>Vect&lt;T&gt;</code> 要实现 <code>Hash</code>，那么首先需要 <code>T</code> 实现 <code>Hash</code>。</p>
<ol start="4">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 修复错误
// 提示: `derive` 是实现一些常用特征的好办法
use std::collections::HashMap;

struct Viking {
    name: String,
    country: String,
}

impl Viking {
    fn new(name: &amp;str, country: &amp;str) -&gt; Viking {
        Viking {
            name: name.to_string(),
            country: country.to_string(),
        }
    }
}

fn main() {
    // 使用 HashMap 来存储 viking 的生命值
    let vikings = HashMap::from([
        (Viking::new("Einar", "Norway"), 25),
        (Viking::new("Olaf", "Denmark"), 24),
        (Viking::new("Harald", "Iceland"), 12),
    ]);

    // 使用 derive 的方式来打印 viking 的当前状态
    for (viking, health) in &amp;vikings {
        println!("{:?} has {} hp", viking, health);
    }
}</code></pre></pre>
<h3 id="容量-1"><a class="header" href="#容量-1">容量</a></h3>
<p>关于容量，我们在之前的 <a href="https://practice-zh.course.rs/collections/vector.html#%E5%AE%B9%E9%87%8F">Vector</a> 中有详细的介绍，而 <code>HashMap</code> 也可以调整容量: 你可以通过 <code>HashMap::with_capacity(uint)</code> 使用指定的容量来初始化，或者使用 <code>HashMap::new()</code> ，后者会提供一个默认的初始化容量。</p>
<h4 id="示例-7"><a class="header" href="#示例-7">示例</a></h4>
<pre><pre class="playground"><code class="language-rust editable edition2021">
use std::collections::HashMap;
fn main() {
    let mut map: HashMap&lt;i32, i32&gt; = HashMap::with_capacity(100);
    map.insert(1, 2);
    map.insert(3, 4);
    // 事实上，虽然我们使用了 100 容量来初始化，但是 map 的容量很可能会比 100 更多
    assert!(map.capacity() &gt;= 100);

    // 对容量进行收缩，你提供的值仅仅是一个允许的最小值，实际上，Rust 会根据当前存储的数据量进行自动设置，当然，这个值会尽量靠近你提供的值，同时还可能会预留一些调整空间

    map.shrink_to(50);
    assert!(map.capacity() &gt;= 50);

    // 让 Rust  自行调整到一个合适的值，剩余策略同上
    map.shrink_to_fit();
    assert!(map.capacity() &gt;= 2);
    println!("Success!")
}</code></pre></pre>
<h3 id="所有权-1"><a class="header" href="#所有权-1">所有权</a></h3>
<p>对于实现了 <code>Copy</code> 特征的类型，例如 <code>i32</code>，那类型的值会被拷贝到 <code>HashMap</code> 中。而对于有所有权的类型，例如 <code>String</code>，它们的值的所有权将被转移到 <code>HashMap</code> 中。</p>
<ol start="5">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 修复错误，尽可能少的去修改代码
// 不要移除任何代码行！
use std::collections::HashMap;
fn main() {
  let v1 = 10;
  let mut m1 = HashMap::new();
  m1.insert(v1, v1);
  println!("v1 is still usable after inserting to hashmap : {}", v1);

  let v2 = "hello".to_string();
  let mut m2 = HashMap::new();
  // 所有权在这里发生了转移
  m2.insert(v2, v1);

  assert_eq!(v2, "hello");

   println!("Success!")
}</code></pre></pre>
<h3 id="三方库-hash-库"><a class="header" href="#三方库-hash-库">三方库 Hash 库</a></h3>
<p>在开头，我们提到过如果现有的 <code>SipHash 1-3</code> 的性能无法满足你的需求，那么可以使用社区提供的替代算法。</p>
<p>例如其中一个社区库的使用方式如下：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::hash::BuildHasherDefault;
use std::collections::HashMap;
// 引入第三方的哈希函数
use twox_hash::XxHash64;


let mut hash: HashMap&lt;_, _, BuildHasherDefault&lt;XxHash64&gt;&gt; = Default::default();
hash.insert(42, "the answer");
assert_eq!(hash.get(&amp;42), Some(&amp;"the answer"));
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>你可以在<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/collections/Hashmap.md">这里</a>找到答案(在 solutions 路径下)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-conversions"><a class="header" href="#type-conversions">Type conversions</a></h1>
<p>There are several ways we can use to perform type conversions, such as <code>as</code>, <code>From/Intro</code>, <code>TryFrom/TryInto</code>, <code>transmute</code> etc.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用-as-进行类型转换"><a class="header" href="#使用-as-进行类型转换">使用 as 进行类型转换</a></h1>
<p>Rust 并没有为基本类型提供隐式的类型转换( coercion )，但是我们可以通过 <code>as</code> 来进行显式地转换。</p>
<ol>
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 修复错误，填空
// 不要移除任何代码
fn main() {
    let decimal = 97.123_f32;

    let integer: __ = decimal as u8;

    let c1: char = decimal as char;
    let c2 = integer as char;

    assert_eq!(integer, 'b' as u8);

    println!("Success!")
}</code></pre></pre>
<ol start="2">
<li>🌟🌟 默认情况下, 数值溢出会导致编译错误，但是我们可以通过添加一行全局注解的方式来避免编译错误(溢出还是会发生)</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    assert_eq!(u8::MAX, 255);
    // 如上所示，u8 类型允许的最大值是 255.
    // 因此以下代码会报溢出的错误： literal out of range for `u8`.
    // **请仔细查看相应的编译错误，从中寻找到解决的办法**
    // **不要修改 main 中的任何代码**
    let v = 1000 as u8;

    println!("Success!")
}</code></pre></pre>
<ol start="3">
<li>🌟🌟  当将任何数值转换成无符号整型 <code>T</code> 时，如果当前的数值不在新类型的范围内，我们可以对当前数值进行加值或减值操作( 增加或减少 <code>T::MAX + 1</code> )，直到最新的值在新类型的范围内，假设我们要将 <code>300</code> 转成 <code>u8</code> 类型，由于<code>u8</code> 最大值是 255，因此 <code>300</code> 不在新类型的范围内并且大于新类型的最大值，因此我们需要减去 <code>T::MAX + 1</code>，也就是 <code>300</code> - <code>256</code> = <code>44</code>。</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    assert_eq!(1000 as u16, __);

    assert_eq!(1000 as u8, __);

    // 事实上，之前说的规则对于正整数而言，就是如下的取模
    println!("1000 mod 256 is : {}", 1000 % 256);

    assert_eq!(-1_i8 as u8, __);
    

    // 从 Rust 1.45 开始，当浮点数超出目标整数的范围时，转化会直接取正整数取值范围的最大或最小值
    assert_eq!(300.1_f32 as u8, __);
    assert_eq!(-100.1_f32 as u8, __);
    

    // 上面的浮点数转换有一点性能损耗，如果大家对于某段代码有极致的性能要求，
    // 可以考虑下面的方法，但是这些方法的结果可能会溢出并且返回一些无意义的值
    // 总之，请小心使用
    unsafe {
        // 300.0 is 44
        println!("300.0 is {}", 300.0_f32.to_int_unchecked::&lt;u8&gt;());
        // -100.0 as u8 is 156
        println!("-100.0 as u8 is {}", (-100.0_f32).to_int_unchecked::&lt;u8&gt;());
        // nan as u8 is 0
        println!("nan as u8 is {}", f32::NAN.to_int_unchecked::&lt;u8&gt;());
    }
}</code></pre></pre>
<ol start="4">
<li>🌟🌟🌟 裸指针可以和代表内存地址的整数互相转换</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 填空
fn main() {
    let mut values: [i32; 2] = [1, 2];
    let p1: *mut i32 = values.as_mut_ptr();
    let first_address: usize = p1 __; 
    let second_address = first_address + 4; // 4 == std::mem::size_of::&lt;i32&gt;()
    let p2: *mut i32 = second_address __; // p2 指向 values 数组中的第二个元素
    unsafe {
        // 将第二个元素加 1
        __
    }
    
    assert_eq!(values[1], 3);

    println!("Success!")
}</code></pre></pre>
<ol start="5">
<li>🌟🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let arr :[u64; 13] = [0; 13];
    assert_eq!(std::mem::size_of_val(&amp;arr), 8 * 13);
    let a: *const [u64] = &amp;arr;
    let b = a as *const [u8];
    unsafe {
        assert_eq!(std::mem::size_of_val(&amp;*b), __)
    }
}</code></pre></pre>
<blockquote>
<p>你可以在<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/type-conversions/as.md">这里</a>找到答案(在 solutions 路径下)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frominto"><a class="header" href="#frominto">From/Into</a></h1>
<p><code>From</code> 特征允许让一个类型定义如何基于另一个类型来创建自己，因此它提供了一个很方便的类型转换的方式。</p>
<p><code>From</code> 和 <code>Into</code> 是配对的，我们只要实现了前者，那后者就会自动被实现：只要实现了 <code>impl From&lt;T&gt; for U</code>， 就可以使用以下两个方法: <code>let u: U = U::from(T)</code> 和 <code>let u:U = T.into()</code>，前者由 <code>From</code> 特征提供，而后者由自动实现的 <code>Into</code> 特征提供。</p>
<p>需要注意的是，当使用 <code>into</code> 方法时，你需要进行显式地类型标注，因为编译器很可能无法帮我们推导出所需的类型。</p>
<p>来看一个例子，我们可以简单的将 <code>&amp;str</code> 转换成 <code>String</code></p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let my_str = "hello";

    // 以下三个转换都依赖于一个事实：String 实现了 From&lt;&amp;str&gt; 特征
    let string1 = String::from(my_str);
    let string2 = my_str.to_string();
    // 这里需要显式地类型标注
    let string3: String = my_str.into();
}</code></pre></pre>
<p>这种转换可以发生是因为标准库已经帮我们实现了 <code>From</code> 特征： <code>impl From&lt;&amp;'_ str&gt; for String</code>。你还可以在<a href="https://doc.rust-lang.org/stable/std/convert/trait.From.html#implementors">这里</a>)找到其它实现 <code>From</code> 特征的常用类型。</p>
<ol>
<li>🌟🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // impl From&lt;bool&gt; for i32
    let i1: i32 = false.into();
    let i2: i32 = i32::from(false);
    assert_eq!(i1, i2);
    assert_eq!(i1, 0);

    // 使用两种方式修复错误
    // 1. 哪个类型实现 From 特征 : impl From&lt;char&gt; for ? , 你可以查看一下之前提到的文档，来找到合适的类型
    // 2. 上一章节中介绍过的某个关键字
    let i3: i32 = 'a'.into();

    // 使用两种方法来解决错误
    let s: String = 'a' as String;

    println!("Success!")
}</code></pre></pre>
<h3 id="为自定义类型实现-from-特征"><a class="header" href="#为自定义类型实现-from-特征">为自定义类型实现 <code>From</code> 特征</a></h3>
<ol start="2">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// From 被包含在 `std::prelude` 中，因此我们没必要手动将其引入到当前作用域来
// use std::convert::From;

#[derive(Debug)]
struct Number {
    value: i32,
}

impl From&lt;i32&gt; for Number {
    // 实现 `from` 方法
}

// 填空
fn main() {
    let num = __(30);
    assert_eq!(num.value, 30);

    let num: Number = __;
    assert_eq!(num.value, 30);

    println!("Success!")
}</code></pre></pre>
<ol start="3">
<li>🌟🌟🌟 当执行错误处理时，为我们自定义的错误类型实现 <code>From</code> 特征是非常有用。这样就可以通过 <code>?</code> 自动将某个错误类型转换成我们自定义的错误类型</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::fs;
use std::io;
use std::num;

enum CliError {
    IoError(io::Error),
    ParseError(num::ParseIntError),
}

impl From&lt;io::Error&gt; for CliError {
    // 实现 from 方法
}

impl From&lt;num::ParseIntError&gt; for CliError {
    // 实现 from 方法
}

fn open_and_parse_file(file_name: &amp;str) -&gt; Result&lt;i32, CliError&gt; {
    // ? 自动将 io::Error 转换成 CliError
    let contents = fs::read_to_string(&amp;file_name)?;
    // num::ParseIntError -&gt; CliError
    let num: i32 = contents.trim().parse()?;
    Ok(num)
}

fn main() {
    println!("Success!")
}</code></pre></pre>
<h3 id="tryfromtryinto"><a class="header" href="#tryfromtryinto">TryFrom/TryInto</a></h3>
<p>类似于 <code>From</code> 和 <code>Into</code>, <code>TryFrom</code> 和 <code>TryInto</code> 也是用于类型转换的泛型特征。</p>
<p>但是又与 <code>From/Into</code> 不同, <code>TryFrom</code> 和 <code>TryInto</code> 可以对转换后的失败进行处理，然后返回一个 <code>Result</code>。</p>
<ol start="4">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// TryFrom 和 TryInto 也被包含在 `std::prelude` 中, 因此以下引入是没必要的
// use std::convert::TryInto;

fn main() {
    let n: i16 = 256;

    // Into 特征拥有一个方法`into`,
    // 因此 TryInto 有一个方法是 ?
    let n: u8 = match n.__() {
        Ok(n) =&gt; n,
        Err(e) =&gt; {
            println!("there is an error when converting: {:?}, but we catch it", e.to_string());
            0
        }
    };

    assert_eq!(n, __);

    println!("Success!")
}</code></pre></pre>
<ol start="5">
<li>🌟🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug, PartialEq)]
struct EvenNum(i32);

impl TryFrom&lt;i32&gt; for EvenNum {
    type Error = ();

    // 实现 `try_from`
    fn try_from(value: i32) -&gt; Result&lt;Self, Self::Error&gt; {
        if value % 2 == 0 {
            Ok(EvenNum(value))
        } else {
            Err(())
        }
    }
}

fn main() {
    assert_eq!(EvenNum::try_from(8), Ok(EvenNum(8)));
    assert_eq!(EvenNum::try_from(5), Err(()));

    // 填空
    let result: Result&lt;EvenNum, ()&gt; = 8i32.try_into();
    assert_eq!(result, __);
    let result: Result&lt;EvenNum, ()&gt; = 5i32.try_into();
    assert_eq!(result, __);

    println!("Success!")
}</code></pre></pre>
<blockquote>
<p>你可以在<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/type-conversions/from-into.md">这里</a>找到答案(在 solutions 路径下)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="其它转换"><a class="header" href="#其它转换">其它转换</a></h1>
<h3 id="将任何类型转换成-string"><a class="header" href="#将任何类型转换成-string">将任何类型转换成 String</a></h3>
<p>只要为一个类型实现了 <code>ToString</code>，就可以将任何类型转换成 <code>String</code>。事实上，这种方式并不是最好的，大家还记得 <code>fmt::Display</code> 特征吗？它可以控制一个类型如何打印，在实现它的时候还会自动实现 <code>ToString</code>。</p>
<ol>
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::fmt;

struct Point {
    x: i32,
    y: i32,
}

impl fmt::Display for Point {
    // 实现 fmt 方法
}

fn main() {
    let origin = Point { x: 0, y: 0 };
    // 填空
    assert_eq!(origin.__, "The point is (0, 0)");
    assert_eq!(format!(__), "The point is (0, 0)");

    println!("Success!")
}</code></pre></pre>
<h3 id="解析-string"><a class="header" href="#解析-string">解析 String</a></h3>
<ol start="2">
<li>🌟🌟🌟 使用 <code>parse</code> 方法可以将一个 <code>String</code> 转换成 <code>i32</code> 数字，这是因为在标准库中为 <code>i32</code> 类型实现了 <code>FromStr</code>: : <code>impl FromStr for i32</code></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 为了使用 `from_str` 方法, 你需要引入该特征到当前作用域中
use std::str::FromStr;
fn main() {
    let parsed: i32 = "5".__.unwrap();
    let turbo_parsed = "10".__.unwrap();
    let from_str = __.unwrap();
    let sum = parsed + turbo_parsed + from_str;
    assert_eq!(sum, 35);

    println!("Success!")
}</code></pre></pre>
<ol start="3">
<li>🌟🌟 还可以为自定义类型实现 <code>FromStr</code> 特征</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::str::FromStr;
use std::num::ParseIntError;

#[derive(Debug, PartialEq)]
struct Point {
    x: i32,
    y: i32
}

impl FromStr for Point {
    type Err = ParseIntError;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        let coords: Vec&lt;&amp;str&gt; = s.trim_matches(|p| p == '(' || p == ')' )
                                 .split(',')
                                 .map(|x| x.trim())
                                 .collect();

        let x_fromstr = coords[0].parse::&lt;i32&gt;()?;
        let y_fromstr = coords[1].parse::&lt;i32&gt;()?;

        Ok(Point { x: x_fromstr, y: y_fromstr })
    }
}
fn main() {
    // 使用两种方式填空
    // 不要修改其它地方的代码
    let p = __;
    assert_eq!(p.unwrap(), Point{ x: 3, y: 4} );

    println!("Success!")
}</code></pre></pre>
<h3 id="deref-特征"><a class="header" href="#deref-特征">Deref 特征</a></h3>
<p>Deref 特征在<a href="https://practice.rs/smart-pointers/deref.html">智能指针 - Deref</a>章节中有更加详细的介绍。</p>
<h3 id="transmute"><a class="header" href="#transmute">transmute</a></h3>
<p><code>std::mem::transmute</code> 是一个 unsafe 函数，可以把一个类型按位解释为另一个类型，其中这两个类型必须有同样的位数( bits )。</p>
<p><code>transmute</code> 相当于将一个类型按位移动到另一个类型，它会将源值的所有位拷贝到目标值中，然后遗忘源值。该函数跟 C 语言中的 <code>memcpy</code> 函数类似。</p>
<p>正因为此，<strong><code>transmute</code> 非常非常不安全!</strong> 调用者必须要自己保证代码的安全性，当然这也是 unsafe 的目的。</p>
<h4 id="示例-8"><a class="header" href="#示例-8">示例</a></h4>
<ol>
<li><code>transmute</code> 可以将一个指针转换成一个函数指针，该转换并不具备可移植性，原因是在不同机器上，函数指针和数据指针可能有不同的位数( size )。</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn foo() -&gt; i32 {
    0
}

fn main() {
    let pointer = foo as *const ();
    let function = unsafe {
        std::mem::transmute::&lt;*const (), fn() -&gt; i32&gt;(pointer)
    };
    assert_eq!(function(), 0);
}</code></pre></pre>
<ol start="2">
<li><code>transmute</code> 还可以扩展或缩短一个不变量的生命周期，将 Unsafe Rust 的不安全性体现的淋漓尽致!</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct R&lt;'a&gt;(&amp;'a i32);
unsafe fn extend_lifetime&lt;'b&gt;(r: R&lt;'b&gt;) -&gt; R&lt;'static&gt; {
    std::mem::transmute::&lt;R&lt;'b&gt;, R&lt;'static&gt;&gt;(r)
}

unsafe fn shorten_invariant_lifetime&lt;'b, 'c&gt;(r: &amp;'b mut R&lt;'static&gt;)
                                             -&gt; &amp;'b mut R&lt;'c&gt; {
    std::mem::transmute::&lt;&amp;'b mut R&lt;'static&gt;, &amp;'b mut R&lt;'c&gt;&gt;(r)
}</code></pre></pre>
<ol start="3">
<li>事实上我们还可以使用一些安全的方法来替代 <code>transmute</code>.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    /*Turning raw bytes(&amp;[u8]) to u32, f64, etc.: */
    let raw_bytes = [0x78, 0x56, 0x34, 0x12];

    let num = unsafe { std::mem::transmute::&lt;[u8; 4], u32&gt;(raw_bytes) };

    // use `u32::from_ne_bytes` instead
    let num = u32::from_ne_bytes(raw_bytes);
    // or use `u32::from_le_bytes` or `u32::from_be_bytes` to specify the endianness
    let num = u32::from_le_bytes(raw_bytes);
    assert_eq!(num, 0x12345678);
    let num = u32::from_be_bytes(raw_bytes);
    assert_eq!(num, 0x78563412);

    /*Turning a pointer into a usize: */
    let ptr = &amp;0;
    let ptr_num_transmute = unsafe { std::mem::transmute::&lt;&amp;i32, usize&gt;(ptr) };

    // Use an `as` cast instead
    let ptr_num_cast = ptr as *const i32 as usize;

    /*Turning an &amp;mut T into an &amp;mut U: */
    let ptr = &amp;mut 0;
    let val_transmuted = unsafe { std::mem::transmute::&lt;&amp;mut i32, &amp;mut u32&gt;(ptr) };

    // Now, put together `as` and reborrowing - note the chaining of `as`
    // `as` is not transitive
    let val_casts = unsafe { &amp;mut *(ptr as *mut i32 as *mut u32) };

    /*Turning an &amp;str into a &amp;[u8]: */
    // this is not a good way to do this.
    let slice = unsafe { std::mem::transmute::&lt;&amp;str, &amp;[u8]&gt;("Rust") };
    assert_eq!(slice, &amp;[82, 117, 115, 116]);

    // You could use `str::as_bytes`
    let slice = "Rust".as_bytes();
    assert_eq!(slice, &amp;[82, 117, 115, 116]);

    // Or, just use a byte string, if you have control over the string
    // literal
    assert_eq!(b"Rust", &amp;[82, 117, 115, 116]);
}</code></pre></pre>
<blockquote>
<p>你可以在<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/type-conversions/others.md">这里</a>找到答案(在 solutions 路径下)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="result-and-panic"><a class="header" href="#result-and-panic">Result and panic</a></h1>
<p>Learning resources:</p>
<ul>
<li>English: <a href="https://doc.rust-lang.org/book/ch09-00-error-handling.html">Rust Book 9.1, 9.2</a></li>
<li>简体中文: <a href="https://course.rs/basic/result-error/intro.html">Rust语言圣经 - 返回值和错误处理</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="panic"><a class="header" href="#panic">panic!</a></h1>
<p>Rust 中最简单的错误处理方式就是使用 <code>panic</code>。它会打印出一条错误信息并打印出栈调用情况，最终结束当前线程:</p>
<ul>
<li>若 panic 发生在 <code>main</code> 线程，那程序会随之退出</li>
<li>如果是在生成的( spawn )子线程中发生 panic, 那么当前的线程会结束，但是程序依然会继续运行</li>
</ul>
<ol>
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 填空
fn drink(beverage: &amp;str) {
    if beverage == "lemonade" {
        println!("Success!");
        // 实现下面的代码
        __
     }

    println!("Exercise Failed if printing out this line!");
}

fn main() {
    drink(__);

    println!("Exercise Failed if printing out this line!");
}</code></pre></pre>
<h2 id="常见的-panic"><a class="header" href="#常见的-panic">常见的 panic</a></h2>
<ol start="2">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 修复所有的 panic，让代码工作
fn main() {
    assert_eq!("abc".as_bytes(), [96, 97, 98]);

    let v = vec![1, 2, 3];
    let ele = v[3];
    let ele = v.get(3).unwrap();

    // 大部分时候编译器是可以帮我们提前发现溢出错误，并阻止编译通过。但是也有一些时候，这种溢出问题直到运行期才会出现
    let v = production_rate_per_hour(2);

    divide(15, 0);

    println!("Success!")
}

fn divide(x:u8, y:u8) {
    println!("{}", x / y)
}

fn production_rate_per_hour(speed: u8) -&gt; f64 {
    let cph: u8 = 221;
    match speed {
        1..=4 =&gt; (speed * cph) as f64,
        5..=8 =&gt; (speed * cph) as f64 * 0.9,
        9..=10 =&gt; (speed * cph) as f64 * 0.77,
        _ =&gt; 0 as f64,
    }
}

pub fn working_items_per_minute(speed: u8) -&gt; u32 {
    (production_rate_per_hour(speed) / 60 as f64) as u32
}</code></pre></pre>
<h3 id="详细的栈调用信息"><a class="header" href="#详细的栈调用信息">详细的栈调用信息</a></h3>
<p>默认情况下，栈调用只会展示最基本的信息:</p>
<pre><code class="language-shell">thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>但是有时候，我们还希望获取更详细的信息:</p>
<ol start="3">
<li>🌟</li>
</ol>
<pre><code class="language-shell">## 填空以打印全部的调用栈
## 提示: 你可以在之前的默认 panic 信息中找到相关线索
$ __ cargo run
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `[97, 98, 99]`,
 right: `[96, 97, 98]`', src/main.rs:3:5
stack backtrace:
   0: rust_begin_unwind
             at /rustc/9d1b2106e23b1abd32fce1f17267604a5102f57a/library/std/src/panicking.rs:498:5
   1: core::panicking::panic_fmt
             at /rustc/9d1b2106e23b1abd32fce1f17267604a5102f57a/library/core/src/panicking.rs:116:14
   2: core::panicking::assert_failed_inner
   3: core::panicking::assert_failed
             at /rustc/9d1b2106e23b1abd32fce1f17267604a5102f57a/library/core/src/panicking.rs:154:5
   4: study_cargo::main
             at ./src/main.rs:3:5
   5: core::ops::function::FnOnce::call_once
             at /rustc/9d1b2106e23b1abd32fce1f17267604a5102f57a/library/core/src/ops/function.rs:227:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
</code></pre>
<h3 id="unwinding-和-abort"><a class="header" href="#unwinding-和-abort"><code>unwinding</code> 和 <code>abort</code></a></h3>
<p>当出现 <code>panic!</code> 时，程序提供了两种方式来处理终止流程：<strong>栈展开</strong>和<strong>直接终止</strong>。</p>
<p>其中，默认的方式就是 <code>栈展开</code>，这意味着 Rust 会回溯栈上数据和函数调用，因此也意味着更多的善后工作，好处是可以给出充分的报错信息和栈调用信息，便于事后的问题复盘。<code>直接终止</code>，顾名思义，不清理数据就直接退出程序，善后工作交与操作系统来负责。</p>
<p>对于绝大多数用户，使用默认选择是最好的，但是当你关心最终编译出的二进制可执行文件大小时，那么可以尝试去使用直接终止的方式，例如下面的配置修改 <code>Cargo.toml</code> 文件，实现在 <a href="result-panic/../first-try/cargo.html#%E6%89%8B%E5%8A%A8%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8C%E9%A1%B9%E7%9B%AE"><code>release</code></a> 模式下遇到 <code>panic</code> 直接终止：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[profile.release]
panic = 'abort'
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>你可以在<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/result-panic/panic.md">这里</a>找到答案(在 solutions 路径下)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="result-and-"><a class="header" href="#result-and-">result and ?</a></h1>
<p><code>Result&lt;T&gt;</code> 是一个枚举类型用于描述返回的结果或错误，它包含两个成员(变体 variants) :</p>
<ul>
<li><code>Ok(T)</code>: 返回一个结果值 T</li>
<li><code>Err(e)</code>: 返回一个错误，<code>e</code> 是具体的错误值</li>
</ul>
<p>简而言之，如果期待一个正确的结果，就返回 <code>Ok</code>，反之则是 <code>Err</code>。</p>
<ol>
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 填空并修复错误
use std::num::ParseIntError;

fn multiply(n1_str: &amp;str, n2_str: &amp;str) -&gt; __ {
    let n1 = n1_str.parse::&lt;i32&gt;();
    let n2 = n2_str.parse::&lt;i32&gt;();
    Ok(n1.unwrap() * n2.unwrap())
}

fn main() {
    let result = multiply("10", "2");
    assert_eq!(result, __);

    let result = multiply("t", "2");
    assert_eq!(result.__, 8);

    println!("Success!")
}</code></pre></pre>
<h3 id=""><a class="header" href="#">?</a></h3>
<p><code>?</code> 跟 <code>unwrap</code> 非常像，但是 <code>?</code> 会返回一个错误，而不是直接 panic.</p>
<ol start="2">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
use std::num::ParseIntError;

// 使用 `?` 来实现 multiply
// 不要使用 unwrap !
fn multiply(n1_str: &amp;str, n2_str: &amp;str) -&gt; __ {
}

fn main() {
    assert_eq!(multiply("3", "4").unwrap(), 12);
    println!("Success!")
}</code></pre></pre>
<ol start="3">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
use std::fs::File;
use std::io::{self, Read};

fn read_file1() -&gt; Result&lt;String, io::Error&gt; {
    let f = File::open("hello.txt");
    let mut f = match f {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut s = String::new();
    match f.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; Err(e),
    }
}

// 填空
// 不要修改其它代码
fn read_file2() -&gt; Result&lt;String, io::Error&gt; {
    let mut s = String::new();

    __;

    Ok(s)
}

fn main() {
    assert_eq!(read_file1().unwrap_err().to_string(), read_file2().unwrap_err().to_string());
    println!("Success!")
}</code></pre></pre>
<h3 id="map--and_then"><a class="header" href="#map--and_then">map &amp; and_then</a></h3>
<p><a href="https://doc.rust-lang.org/stable/std/result/enum.Result.html#method.map">map</a> and <a href="https://doc.rust-lang.org/stable/std/result/enum.Result.html#method.and_then">and_then</a> 是两个常用的组合器( combinator )，可以用于 <code>Result&lt;T, E&gt;</code> (也可用于 <code>Option&lt;T&gt;</code>).</p>
<ol start="4">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::num::ParseIntError;

// 使用两种方式填空: map, and then
fn add_two(n_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
   n_str.parse::&lt;i32&gt;().__
}

fn main() {
    assert_eq!(add_two("4").unwrap(), 6);

    println!("Success!")
}</code></pre></pre>
<ol start="5">
<li>🌟🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::num::ParseIntError;

// 使用 Result 重写后，我们使用模式匹配的方式来处理，而无需使用 `unwrap`
// 但是这种写法实在过于啰嗦..
fn multiply(n1_str: &amp;str, n2_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    match n1_str.parse::&lt;i32&gt;() {
        Ok(n1)  =&gt; {
            match n2_str.parse::&lt;i32&gt;() {
                Ok(n2)  =&gt; {
                    Ok(n1 * n2)
                },
                Err(e) =&gt; Err(e),
            }
        },
        Err(e) =&gt; Err(e),
    }
}

// 重写上面的 `multiply` ，让它尽量简洁
// 提示：使用 `and_then` 和 `map`
fn multiply1(n1_str: &amp;str, n2_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    // 实现...
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!("n is {}", n),
        Err(e) =&gt; println!("Error: {}", e),
    }
}

fn main() {
    let twenty = multiply1("10", "2");
    print(twenty);

    // 下面的调用会提供更有帮助的错误信息
    let tt = multiply("t", "2");
    print(tt);

    println!("Success!")
}</code></pre></pre>
<h3 id="类型别名"><a class="header" href="#类型别名">类型别名</a></h3>
<p>如果我们要在代码中到处使用 <code>std::result::Result&lt;T, ParseIntError&gt;</code> ，那毫无疑问，代码将变得特别冗长和啰嗦，对于这种情况，可以使用类型别名来解决。</p>
<p>例如在标准库中，就在大量使用这种方式来简化代码: <a href="https://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a>.</p>
<ol start="6">
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::num::ParseIntError;

// 填空
type __;

// 使用上面的别名来引用原来的 `Result` 类型
fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Res&lt;i32&gt; {
    first_number_str.parse::&lt;i32&gt;().and_then(|first_number| {
        second_number_str.parse::&lt;i32&gt;().map(|second_number| first_number * second_number)
    })
}

// 同样, 这里也使用了类型别名来简化代码
fn print(result: Res&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!("n is {}", n),
        Err(e) =&gt; println!("Error: {}", e),
    }
}

fn main() {
    print(multiply("10", "2"));
    print(multiply("t", "2"));

    println!("Success!")
}</code></pre></pre>
<h3 id="在-fn-main-中使用-result"><a class="header" href="#在-fn-main-中使用-result">在 <code>fn main</code> 中使用 <code>Result</code></a></h3>
<p>一个典型的 <code>main</code> 函数长这样:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    println!("Hello World!");
}</code></pre></pre>
<p>事实上 <code>main</code> 函数还可以返回一个 <code>Result</code> 类型：如果 <code>main</code> 函数内部发生了错误，那该错误会被返回并且打印出一条错误的 debug 信息。</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
use std::num::ParseIntError;

fn main() -&gt; Result&lt;(), ParseIntError&gt; {
    let number_str = "10";
    let number = match number_str.parse::&lt;i32&gt;() {
        Ok(number)  =&gt; number,
        Err(e) =&gt; return Err(e),
    };
    println!("{}", number);
    Ok(())
}</code></pre></pre>
<blockquote>
<p>你可以在<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/result-panic/result.md">这里</a>找到答案(在 solutions 路径下)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包和模块"><a class="header" href="#包和模块">包和模块</a></h1>
<p>学习资料:</p>
<ul>
<li>简体中文: <a href="https://course.rs/basic/crate-module/intro.html">Rust语言圣经 - 包和模块</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="package-and-crate"><a class="header" href="#package-and-crate">Package and Crate</a></h1>
<p><code>package</code> 是你通过 <code>Cargo</code> 创建的工程或项目，因此在 <code>package</code> 的根目录下会有一个 <code>Cargo.toml</code> 文件。</p>
<ol>
<li>🌟 创建一个 <code>package</code>，拥有以下目录结构:</li>
</ol>
<pre><code class="language-shell">.
├── Cargo.toml
└── src
    └── main.rs

1 directory, 2 files
</code></pre>
<pre><code class="language-toml"># in Cargo.toml
[package]
name = "hello-package"
version = "0.1.0"
edition = "2021"
</code></pre>
<blockquote>
<p>注意! 我们会在包与模块中使用上面的项目作为演示，因此不要删除</p>
</blockquote>
<ol start="2">
<li>🌟 创建一个 package，拥有以下目录结构:</li>
</ol>
<pre><code class="language-shell">.
├── Cargo.toml
└── src
    └── lib.rs

1 directory, 2 files
</code></pre>
<pre><code class="language-toml"># in Cargo.toml
[package]
name = "hello-package1"
version = "0.1.0"
edition = "2021"
</code></pre>
<blockquote>
<p>该项目可以安全的移除</p>
</blockquote>
<ol start="3">
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">/* 使用你的答案填空 */

// Q: package 1# 和 2# 的区别是什么 ?
// A: __</code></pre></pre>
<h2 id="包crate"><a class="header" href="#包crate">包Crate</a></h2>
<p>一个包可以是二进制也可以一个依赖库。每一个包都有一个包根，例如二进制包的包根是 <code>src/main.rs</code>，库包的包根是 <code>src/lib.rs</code>。包根是编译器开始处理源代码文件的地方，同时也是包模块树的根部。</p>
<p>在 package <code>hello-package</code> 中，有一个二进制包，该包与 <code>package</code> 同名 : <code>hello-package</code>,  其中 <code>src/main.rs</code> 是该二进制包的包根.</p>
<p>与 <code>hello-package</code> 类似, <code>hello-package1</code> 同样包含一个包，但是与之前的二进制包不同，该 package 包含的是库包，其中 <code>src/lib.rs</code> 是其包根.</p>
<ol start="4">
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">/* 填空 */

// Q: package `hello-package1` 中的库包名称是?
// A: __</code></pre></pre>
<ol start="5">
<li>🌟🌟 为 <code>hello-package</code> 添加一个库包，并且完成以下目录结构的填空:</li>
</ol>
<pre><code class="language-shell editable"># 填空
.
├── Cargo.lock
├── Cargo.toml
├── src
│   ├── __
│   └── __
</code></pre>
<p>在上一个步骤后，我们的 <code>hello-package</code> 中已经存在两个包：一个二进制包和一个库包，两个包的名称都与 package 相同：<code>hello-package</code>。</p>
<ol start="6">
<li>🌟🌟🌟 一个 package 最多只能包含一个库包，但是却可以包含多个二进制包：通过将二进制文件放入到 <code>src/bin</code> 目录下实现: <strong>该目录下的每个文件都是一个独立的二进制包，包名与文件名相同，不再与 package 的名称相同。</strong>.</li>
</ol>
<pre><code class="language-shell editable"># 创建一个 a package 包含以下包： 
# 1. 三个二进制包: `hello-package`, `main1` and `main2`
# 2. 一个库包
# 并完成以下目录结构的填空
.
├── Cargo.toml
├── Cargo.lock
├── src
│   ├── __
│   ├── __
│   └── __
│       └── __
│       └── __
├── tests # 存放集成测试文件的目录
│   └── some_integration_tests.rs
├── benches # 存放 benchmark 文件的目录dir for benchmark files
│   └── simple_bench.rs
└── examples # 存放示例文件的目录
    └── simple_example.rs
</code></pre>
<p>可以看到，上面的 package 结构非常标准，你可以在很多 Rust 项目中看到该结构的身影。</p>
<blockquote>
<p>你可以在<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/crate-module/crate.md">这里</a>找到答案(在 solutions 路径下)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="module"><a class="header" href="#module">Module</a></h1>
<p>在 Rust 语言圣经中，我们已经深入讲解过<a href="https://course.rs/basic/crate-module/module.html">模块module</a>，这里就不再赘述，直接开始我们的练习。</p>
<p>之前我们创建了一个 package <code>hello-package</code>，它的目录结构在经过多次修改后，变成了以下模样:</p>
<pre><code class="language-shell">.
├── Cargo.toml
├── src
│   ├── lib.rs
│   └── main.rs
</code></pre>
<p>下面，我们来为其中的库包创建一些模块，然后在二进制包中使用这些模块。</p>
<ol>
<li>🌟🌟 根据以下的模块树描述实现模块 <code>front_of_house</code> :</li>
</ol>
<pre><code class="language-shell">库包的根(src/lib.rs)
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         ├── take_payment
         └── complain
</code></pre>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 填空
// in __.rs

mod front_of_house {
    // 实现此模块
}</code></pre></pre>
<ol start="2">
<li>🌟🌟 让我们在库包的根中定义一个函数 <code>eat_at_restaurant</code>, 然后在该函数中调用之前创建的函数 <code>eat_at_restaurant</code></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// in lib.rs

// 填空并修复错误

// 提示：你需要通过 `pub` 将一些项标记为公有的，这样模块 `front_of_house` 中的项才能被模块外的项访问
mod front_of_house {
    /* ...snip... */
}

pub fn eat_at_restaurant() {
    // 使用绝对路径调用
    __.add_to_waitlist();

    // 使用相对路径调用
     __.add_to_waitlist();
}</code></pre></pre>
<ol start="3">
<li>🌟🌟 我们还可以使用 <code>super</code> 来导入父模块中的项</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// in lib.rs

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        // 使用三种方式填空
        //1. 使用关键字 `super`
        //2. 使用绝对路径
        __.serve_order();
    }

    fn cook_order() {}
}</code></pre></pre>
<h3 id="将模块分离并放入独立的文件中"><a class="header" href="#将模块分离并放入独立的文件中">将模块分离并放入独立的文件中</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in lib.rs
pub mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}

        pub fn seat_at_table() -&gt; String {
            String::from("sit down please")
        }
    }

    pub mod serving {
        pub fn take_order() {}

        pub fn serve_order() {}

        pub fn take_payment() {}

        // 我猜你不希望顾客听到你在抱怨他们，因此让这个函数私有化吧
        fn complain() {} 
    }
}

pub fn eat_at_restaurant() -&gt; String {
    front_of_house::hosting::add_to_waitlist();
    
    back_of_house::cook_order();

    String::from("yummy yummy!")
}

pub mod back_of_house {
    pub fn fix_incorrect_order() {
        cook_order();
        crate::front_of_house::serving::serve_order();
    }

    pub fn cook_order() {}
}
<span class="boring">}</span></code></pre></pre>
<ol start="4">
<li>🌟🌟🌟🌟 请将上面的模块和代码分离到以下目录文件中e :</li>
</ol>
<pre><code class="language-shell">.
├── Cargo.toml
├── src
│   ├── back_of_house.rs
│   ├── front_of_house
│   │   ├── hosting.rs
│   │   ├── mod.rs
│   │   └── serving.rs
│   ├── lib.rs
│   └── main.rs
</code></pre>
<pre><pre class="playground"><code class="language-rust editable edition2021">// in src/lib.rs

// IMPLEMENT...</code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable edition2021">// in src/back_of_house.rs

// IMPLEMENT...</code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable edition2021">// in src/front_of_house/mod.rs

// IMPLEMENT...</code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable edition2021">// in src/front_of_house/hosting.rs

// IMPLEMENT...</code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable edition2021">// in src/front_of_house/serving.rs

// IMPLEMENT...</code></pre></pre>
<h3 id="从二进制包中访问库包的代码"><a class="header" href="#从二进制包中访问库包的代码">从二进制包中访问库包的代码</a></h3>
<p><strong>请确保你已经完成了第四题，然后再继续进行.</strong></p>
<p>当到底此处时，你的项目结构应该如下所示:</p>
<pre><code class="language-shell">.
├── Cargo.toml
├── src
│   ├── back_of_house.rs
│   ├── front_of_house
│   │   ├── hosting.rs
│   │   ├── mod.rs
│   │   └── serving.rs
│   ├── lib.rs
│   └── main.rs
</code></pre>
<ol start="5">
<li>🌟🌟🌟现在我们可以从二进制包中发起函数调用了.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// in src/main.rs

// 填空并修复错误
fn main() {
    assert_eq!(__, "sit down please");
    assert_eq!(__,"yummy yummy!");
}</code></pre></pre>
<blockquote>
<p>你可以在<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/crate-module/module.md">这里</a>找到答案(在 solutions 路径下)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-and-pub"><a class="header" href="#use-and-pub">use and pub</a></h1>
<ol>
<li>🌟 使用 <code>use</code> 可以将两个同名类型引入到当前作用域中，但是别忘了 <code>as</code> 关键字.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::fmt::Result;
use std::io::Result;

fn main() {}</code></pre></pre>
<ol start="2">
<li>🌟🌟 如果我们在使用来自同一个包或模块中的多个不同项，那么可以通过简单的方式将它们一次性引入进来</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// 使用两种方式填空
// 不要添加新的代码行
use std::collections::__;

fn main() {
    let _c1:HashMap&lt;&amp;str, i32&gt; = HashMap::new();
    let mut c2 = BTreeMap::new();
    c2.insert(1, "a");
    let _c3: HashSet&lt;i32&gt; = HashSet::new();
}</code></pre></pre>
<h3 id="使用-pub-use-进行再导出"><a class="header" href="#使用-pub-use-进行再导出">使用 <code>pub use</code> 进行再导出</a></h3>
<ol start="3">
<li>🌟🌟🌟 在之前创建的<code>hello-package</code> 的库包中, 添加一些代码让下面的代码能够正常工作</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    assert_eq!(hello_package::hosting::seat_at_table(), "sit down please");
     assert_eq!(hello_package::eat_at_restaurant(),"yummy yummy!");
}</code></pre></pre>
<h3 id="pubin-crate"><a class="header" href="#pubin-crate">pub(in Crate)</a></h3>
<p>有时我们希望某一个项只对特定的包可见，那么就可以使用 <code>pub(in Crate)</code> 语法.</p>
<h4 id="示例-9"><a class="header" href="#示例-9">示例</a></h4>
<pre><pre class="playground"><code class="language-rust editable edition2021">pub mod a {
    pub const I: i32 = 3;

    fn semisecret(x: i32) -&gt; i32 {
        use self::b::c::J;
        x + J
    }

    pub fn bar(z: i32) -&gt; i32 {
        semisecret(I) * z
    }
    pub fn foo(y: i32) -&gt; i32 {
        semisecret(I) + y
    }

    mod b {
        pub(in crate::a) mod c {
            pub(in crate::a) const J: i32 = 4;
        }
    }
}</code></pre></pre>
<h3 id="完整代码"><a class="header" href="#完整代码">完整代码</a></h3>
<p>至此，包与模块章节已经结束，关于 <code>hello-package</code> 的完整代码可以在<a href="https://github.com/sunface/rust-by-practice/tree/master/practices/hello-package">这里</a> 找到.</p>
<blockquote>
<p>你可以在<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/crate-module/use-pub.md">这里</a>找到答案(在 solutions 路径下)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="注释和文档"><a class="header" href="#注释和文档">注释和文档</a></h1>
<p>本章的学习资料在<a href="https://course.rs/basic/comment.html">这里</a>，大家可以先行学习后再来做题。</p>
<h2 id="注释"><a class="header" href="#注释">注释</a></h2>
<ol>
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
/* 只使用注释让下面代码工作! */
fn main() {
    todo!();
    unimplemented!();

    assert_eq!(6, 5 + 3 + 2 + 1 )
}</code></pre></pre>
<h2 id="文档注释"><a class="header" href="#文档注释">文档注释</a></h2>
<p>文档注释会被解析为 HTML 文件，并支持 <code>Markdown</code> 语法。</p>
<p>在开始之前，我们需要创建一个新的项目用于后面的练习: <code>cargo new --lib doc-comments</code>.</p>
<h3 id="行文档注释-"><a class="header" href="#行文档注释-">行文档注释 <code>///</code></a></h3>
<p>为 <code>add_one</code> 函数添加文档</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in lib.rs

/// Add one to the given value and return the value
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
<span class="boring">}</span></code></pre></pre>
<h3 id="cargo-doc"><a class="header" href="#cargo-doc">Cargo doc</a></h3>
<p>我们可以使用 <code>cargo doc --open</code> 来生成 HTML 文件，并自动在浏览器中打开网页。</p>
<h3 id="块文档注释---"><a class="header" href="#块文档注释---">块文档注释 <code>/** ... */</code></a></h3>
<p>为函数 <code>add_two</code> 添加文档:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/** Add two to the given value and return a new value

<span class="boring">Examples
</span>
let arg = 5;
let answer = my_crate::add_two(arg);

assert_eq!(7, answer);

*/
pub fn add_two(x: i32) -&gt; i32 {
    x + 2
}
<span class="boring">}</span></code></pre></pre>
<h3 id="为包和模块创建文档注释"><a class="header" href="#为包和模块创建文档注释">为包和模块创建文档注释</a></h3>
<p>我们还可以创建包和模块的注释，用于描述它们的功能。</p>
<p>首先，来为我们的库包添加一些文档注释:</p>
<blockquote>
<p>注意: 必须要将包、模块注释放置在包根或模块文件的最顶部</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! # 文档注释
//! 
//! 该库用于文档注释的教学

// in lib.rs
pub mod compute;
<span class="boring">}</span></code></pre></pre>
<p>同样的，我们还可以使用块注释来达成目的:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/*! # 文档注释

 该库用于文档注释的教学 */
<span class="boring">}</span></code></pre></pre>
<p>下一步，创建一个新的模块文件 <code>src/compute.rs</code>, 然后在其中添加以下注释:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! 本模块用于处理一些复杂计算

// in compute.rs
<span class="boring">}</span></code></pre></pre>
<p>然后运行 <code>cargo doc --open</code> 查看下结果。</p>
<h3 id="文档测试"><a class="header" href="#文档测试">文档测试</a></h3>
<p>细心的同学可能会发现之前的 <code>add_one</code> 和 <code>add_tow</code> 的文档注释中，包含了两个示例代码块.</p>
<p>以上示例不仅仅是作为文档用于演示你的函数该如何使用，它的另一个作用就是用于文档测试 <code>cargo test</code>。</p>
<ol start="2">
<li>🌟🌟 但是在这两个函数的示例中，存在错误，请修复它们并使用 <code>cargo test</code> 获取以下输出结果:</li>
</ol>
<pre><code class="language-shell">running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests doc-comments

running 2 tests
test src/lib.rs - add_one (line 11) ... ok
test src/lib.rs - add_two (line 26) ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.55s
</code></pre>
<ol start="3">
<li>🌟🌟 有时我们会期望示例的结果是一个 panic。将以下代码添加到 <code>src/compute.rs</code> ，并且让  <code>cargo test</code> 成功运行.</li>
</ol>
<blockquote>
<p>你只能修改注释，不要修改 <code>fn div</code></p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in src/compute.rs

/// # Panics
///
/// The function panics if the second argument is zero.
///
/// ```rust,should_panic
/// // panics on division by zero
/// doc_comments::compute::div(10, 0);
/// ```
pub fn div(a: i32, b: i32) -&gt; i32 {
    if b == 0 {
        panic!("Divide-by-zero error");
    }

    a / b
}
<span class="boring">}</span></code></pre></pre>
<ol start="4">
<li>🌟🌟 有时我们会想要隐藏文档，但是保留文档测试</li>
</ol>
<p>将以下代码添加到 <code>src/compute.rs</code> ,</p>
<pre><pre class="playground"><code class="language-rust edition2021">// in src/compute.rs

/// ```
/// # fn try_main() -&gt; Result&lt;(), String&gt; {
/// let res = doc_comments::compute::try_div(10, 0)?;
/// # Ok(()) // returning from try_main
/// # }
/// # fn main() { 
/// #    try_main().unwrap();
/// #
/// # }
/// ```
pub fn try_div(a: i32, b: i32) -&gt; Result&lt;i32, String&gt; {
    if b == 0 {
        Err(String::from("Divide-by-zero"))
    } else {
        Ok(a / b)
    }
}</code></pre></pre>
<p>然后修改以上代码已实现两个目标:</p>
<ul>
<li>文档注释不能出现在 <code>cargo doc --open</code> 生成的网页中</li>
<li>运行测试，并成功看到以下结果:</li>
</ul>
<pre><code class="language-shell">running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests doc-comments

running 4 tests
test src/compute.rs - compute::div (line 7) ... ok
test src/lib.rs - add_two (line 27) ... ok
test src/lib.rs - add_one (line 11) ... ok
test src/compute.rs - compute::try_div (line 20) ... ok

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.51s
</code></pre>
<h3 id="代码跳转"><a class="header" href="#代码跳转">代码跳转</a></h3>
<p>Rust 为我们提供一个非常强大的特性：可以在文档注释中实现代码跳转。</p>
<p>将以下代码添加到 <code>src/lib.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in lib.rs

/// Add one to the given value and return a [`Option`] type
pub fn add_three(x: i32) -&gt; Option&lt;i32&gt; {
    Some(x + 3)
}
<span class="boring">}</span></code></pre></pre>
<p>除了跳转到标准库中，我们还能跳转到项目中的其它模块。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in lib.rs

mod a {
    /// Add four to the given value and return a [`Option`] type
    /// [`crate::MySpecialFormatter`]
    pub fn add_four(x: i32) -&gt; Option&lt;i32&gt; {
        Some(x + 4)
    }
}

struct MySpecialFormatter;
<span class="boring">}</span></code></pre></pre>
<h3 id="文档属性"><a class="header" href="#文档属性">文档属性</a></h3>
<p>下面是很常用的 <code>#[doc]</code> 属性，该属性可以被 <code>rustdoc</code> 所使用。</p>
<h3 id="inline"><a class="header" href="#inline"><code>inline</code></a></h3>
<p>可以用于内联文档, 而不是链接到一个单独的页面。</p>
<pre><code class="language-rust ignore">#[doc(inline)]
pub use bar::Bar;

/// bar docs
mod bar {
    /// the docs for Bar
    pub struct Bar;
}</code></pre>
<h3 id="no_inline"><a class="header" href="#no_inline"><code>no_inline</code></a></h3>
<p>用于防止链接到单独的页面或其它地方。</p>
<pre><code class="language-rust ignore">// Example from libcore/prelude
#[doc(no_inline)]
pub use crate::mem::drop;</code></pre>
<h3 id="hidden"><a class="header" href="#hidden"><code>hidden</code></a></h3>
<p>通过这个属性让 <code>rustdoc</code> 不要将下面的项包含在文档中:</p>
<pre><code class="language-rust editable ignore">// Example from the futures-rs library
#[doc(hidden)]
pub use self::async_await::*;</code></pre>
<p>对文档来说，<code>rustdoc</code> 被社区广泛采用，大家所看到的<a href="https://doc.rust-lang.org/std/">标准库文档</a>也是基于此生成的。</p>
<h3 id="完整的代码"><a class="header" href="#完整的代码">完整的代码</a></h3>
<p><code>doc-comments</code> 的完整代码可以在<a href="https://github.com/sunface/rust-by-practice/tree/master/practices/doc-comments">这里找到</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="格式化输出"><a class="header" href="#格式化输出">格式化输出</a></h1>
<h2 id="位置参数"><a class="header" href="#位置参数">位置参数</a></h2>
<p>1.🌟🌟</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">/* 填空 */
fn main() {
    println!("{0}, this is {1}. {1}, this is {0}", "Alice", "Bob");// =&gt; Alice, this is Bob. Bob, this is Alice
    assert_eq!(format!("{1}{0}", 1, 2), __);
    assert_eq!(format!(__, 1, 2), "2112");
    println!("Success!");
}</code></pre></pre>
<h2 id="具名参数"><a class="header" href="#具名参数">具名参数</a></h2>
<p>2.🌟🌟</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    println!("{argument}", argument = "test"); // =&gt; "test"

    /* 填空 */
    assert_eq!(format!("{name}{}", 1, __), "21");
    assert_eq!(format!(__,a = "a", b = 'b', c = 3 ), "a 3 b");
    
    /* 修复错误 */
    // 具名参数必须放在其它参数后面
    println!("{abc} {1}", abc = "def", 2);

    println!("Success!")
}</code></pre></pre>
<h2 id="字符串对齐"><a class="header" href="#字符串对齐">字符串对齐</a></h2>
<p>3.🌟🌟 默认情况下，通过空格来填充字符串</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // 下面两个都是通过 5 个空格来填充
    println!("Hello {:5}!", "x"); // =&gt;  "Hello x    !"  
    println!("Hello {:1$}!", "x", 5); // =&gt;  "Hello x    !"

    /* 填空 */
    assert_eq!(format!("Hello __!", 5, "x"), "Hello x    !");
    assert_eq!(format!("Hello __!", "x", width = 5), "Hello x    !");

    println!("Success!")
}</code></pre></pre>
<p>4.🌟🌟🌟 左对齐, 右对齐, 使用指定的字符填充</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // 左对齐
    println!("Hello {:&lt;5}!", "x"); // =&gt; Hello x    !
    // 右对齐
    assert_eq!(format!("Hello __!", "x"), "Hello     x!");
    // 居中对齐
    assert_eq!(format!("Hello __!", "x"), "Hello   x  !");

    // 左对齐，并使用 `&amp;` 填充
    assert_eq!(format!("Hello {:&amp;&lt;5}!", "x"), __);

    println!("Success!")
}</code></pre></pre>
<p>5.🌟🌟 我们还能使用 0 来填充数字</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    println!("Hello {:5}!", 5); // =&gt; Hello     5!
    println!("Hello {:+}!", 5); // =&gt;  Hello +5!
    println!("Hello {:05}!", 5); // =&gt; Hello 00005!
    println!("Hello {:05}!", -5); // =&gt; Hello -0005!

    /* 填空 */
    assert!(format!("{number:0&gt;width$}", number=1, width=6) == __);
    
    println!("Success!")
}</code></pre></pre>
<h2 id="精度"><a class="header" href="#精度">精度</a></h2>
<p>6.🌟🌟 浮点数精度</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
/* 填空 */
fn main() {
    let v = 3.1415926;

    println!("{:.1$}", v, 4); // same as {:.4} =&gt; 3.1416 

    assert_eq!(format!("__", v), "3.14");
    assert_eq!(format!("__", v), "+3.14");
    assert_eq!(format!("__", v), "3");

    println!("Success!")
}</code></pre></pre>
<p>7.🌟🌟🌟 字符串长度</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let s = "Hello, world!";

    println!("{0:.5}", s); // =&gt; Hello

    assert_eq!(format!("Hello __!", 3, "abcdefg"), "Hello abc!");

    println!("Success!")
}</code></pre></pre>
<h2 id="二进制-八进制-十六进制"><a class="header" href="#二进制-八进制-十六进制">二进制, 八进制, 十六进制</a></h2>
<ul>
<li>format!("{}", foo) -&gt; "3735928559"</li>
<li>format!("0x{:X}", foo) -&gt; "0xDEADBEEF"</li>
<li>format!("0o{:o}", foo) -&gt; "0o33653337357"</li>
</ul>
<p>8.🌟🌟</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    assert_eq!(format!("__", 27), "0b11011");
    assert_eq!(format!("__", 27), "0o33");
    assert_eq!(format!("__", 27), "0x1b");
    assert_eq!(format!("__", 27), "0x1B");

    println!("{:x}!", 27); // 没有前缀的十六进制 =&gt; 1b

    println!("{:#010b}", 27); // 使用 0 来填充二进制，宽度为 10 =&gt; 0b00011011

    println!("Success!")
}</code></pre></pre>
<h2 id="捕获环境中的值"><a class="header" href="#捕获环境中的值">捕获环境中的值</a></h2>
<p>9.🌟🌟🌟</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn get_person() -&gt; String {
    String::from("sunface")
}

fn get_format() -&gt; (usize, usize) {
    (4, 1)
}


fn main() {
    let person = get_person();
    println!("Hello, {person}!");

    let (width, precision) = get_format();
    let scores = [("sunface", 99.12), ("jack", 60.34)];
    /* 让下面的代码输出:
    sunface: 99.1
    jack: 60.3
    */
    for (name, score) in scores {
        println!("{name}: __");
    }
}</code></pre></pre>
<h2 id="others"><a class="header" href="#others">Others</a></h2>
<p><strong>Example</strong></p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // 指数
    println!("{:2e}", 1000000000); // =&gt; 1e9
    println!("{:2E}", 1000000000); // =&gt; 1E9

    // 指针地址
    let v= vec![1, 2, 3];
    println!("{:p}", v.as_ptr()); // =&gt; 0x600002324050

    // 转义
    println!("Hello {{}}"); // =&gt; Hello {}
}</code></pre></pre>
<blockquote>
<p>你可以在<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/formatted-output/formatting.md">这里</a>找到答案(在 solutions 路径下)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="生命周期"><a class="header" href="#生命周期">生命周期</a></h1>
<p>学习资料:</p>
<ul>
<li>简体中文: <a href="https://course.rs/advance/lifetime/intro.html">Rust语言圣经 - 生命周期</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="生命周期基础"><a class="header" href="#生命周期基础">生命周期基础</a></h2>
<p>编译器通过生命周期来确保所有的借用都是合法的，典型的，一个变量在创建时生命周期随之开始，销毁时生命周期也随之结束。</p>
<h2 id="生命周期的范围"><a class="header" href="#生命周期的范围">生命周期的范围</a></h2>
<ol>
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">/* 为 `i` 和 `borrow2` 标注合适的生命周期范围 */


// `i` 拥有最长的生命周期，因为它的作用域完整的包含了 `borrow1` 和 `borrow2` 。
// 而 `borrow1` 和 `borrow2` 的生命周期并无关联，因为它们的作用域没有重叠
fn main() {
    let i = 3;                                             
    {                                                    
        let borrow1 = &amp;i; // `borrow1` 生命周期开始. ──┐
        //                                                │
        println!("borrow1: {}", borrow1); //              │
    } // `borrow1` 生命周期结束. ──────────────────────────────────┘
    {                                                    
        let borrow2 = &amp;i; 
                                                        
        println!("borrow2: {}", borrow2);               
    }                                                   
}   </code></pre></pre>
<ol start="2">
<li>🌟🌟</li>
</ol>
<p><strong>示例</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &amp;x;           // --+-- 'a  |
                          //   |       |
    println!("r: {}", r); //   |       |
                          // --+       |
}                         // ----------+
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable edition2021">/* 像上面的示例一样，为 `r` 和 `x` 标注生命周期，然后从生命周期的角度. */

fn main() {  
    {
        let r;                // ---------+-- 'a
                              //          |
        {                     //          |
            let x = 5;        // -+-- 'b  |
            r = &amp;x;           //  |       |
        }                     // -+       |
                              //          |
        println!("r: {}", r); //          |
    }                         // ---------+
}</code></pre></pre>
<h2 id="生命周期标注"><a class="header" href="#生命周期标注">生命周期标注</a></h2>
<p>Rust 的借用检查器使用显式的生命周期标注来确定一个引用的合法范围。但是对于用户来说，我们在大多数场景下，都无需手动去标注生命周期，原因是编译器会在某些情况下自动应用生命周期消除规则。</p>
<p>在了解编译器使用哪些规则帮我们消除生命周期之前，首先还是需要知道该如何手动标记生命周期。</p>
<h4 id="函数-2"><a class="header" href="#函数-2">函数</a></h4>
<p><strong>大家先忽略生命周期消除规则</strong>，让我们看看，函数签名中的生命周期有哪些限制:</p>
<ul>
<li>需要为每个引用标注上合适的生命周期</li>
<li>返回值中的引用，它的生命周期要么跟某个引用参数相同，要么是 <code>'static</code></li>
</ul>
<p><strong>示例</strong></p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 引用参数中的生命周期 'a 至少要跟函数活得一样久
fn print_one&lt;'a&gt;(x: &amp;'a i32) {
    println!("`print_one`: x is {}", x);
}

// 可变引用依然需要标准生命周期
fn add_one&lt;'a&gt;(x: &amp;'a mut i32) {
    *x += 1;
}

// 下面代码中，每个参数都拥有自己独立的生命周期，事实上，这个例子足够简单，因此它们应该被标记上相同的生命周期 `'a`，但是对于复杂的例子而言，独立的生命周期标注是可能存在的
fn print_multi&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32) {
    println!("`print_multi`: x is {}, y is {}", x, y);
}

// 返回一个通过参数传入的引用是很常见的，但是这种情况下需要标注上正确的生命周期
fn pass_x&lt;'a, 'b&gt;(x: &amp;'a i32, _: &amp;'b i32) -&gt; &amp;'a i32 { x }

fn main() {
    let x = 7;
    let y = 9;
    
    print_one(&amp;x);
    print_multi(&amp;x, &amp;y);
    
    let z = pass_x(&amp;x, &amp;y);
    print_one(z);

    let mut t = 3;
    add_one(&amp;mut t);
    print_one(&amp;t);
}</code></pre></pre>
<ol start="3">
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">/* 添加合适的生命周期标注，让下面的代码工作 */
fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}

fn main() {}</code></pre></pre>
<ol start="4">
<li>🌟🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">/* 使用三种方法修复下面的错误  */
fn invalid_output&lt;'a&gt;() -&gt; &amp;'a String { 
    &amp;String::from("foo") 
}

fn main() {
}</code></pre></pre>
<ol start="5">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// `print_refs` 有两个引用参数，它们的生命周期 `'a` 和 `'b` 至少得跟函数活得一样久
fn print_refs&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32) {
    println!("x is {} and y is {}", x, y);
}

/* 让下面的代码工作 */
fn failed_borrow&lt;'a&gt;() {
    let _x = 12;

    // ERROR: `_x` 活得不够久does not live long enough
    let y: &amp;'a i32 = &amp;_x;

    // 在函数内使用 `'a` 将会报错，原因是 `&amp;_x` 的生命周期显然比 `'a` 要小
    // 你不能将一个小的生命周期强转成大的
}

fn main() {
    let (four, nine) = (4, 9);
    

    print_refs(&amp;four, &amp;nine);
    // 这里，four 和 nice 的生命周期必须要比函数 print_refs 长
    
    failed_borrow();
    // `failed_borrow`  没有传入任何引用去限制生命周期 `'a`，因此，此时的 `'a` 生命周期是没有任何限制的，它默认是 `'static`
}</code></pre></pre>
<h4 id="structs"><a class="header" href="#structs">Structs</a></h4>
<ol start="6">
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">/* 增加合适的生命周期标准，让代码工作 */

// `i32` 的引用必须比 `Borrowed` 活得更久
#[derive(Debug)]
struct Borrowed(&amp;i32);

// 类似的，下面两个引用也必须比结构体 `NamedBorrowed` 活得更久
#[derive(Debug)]
struct NamedBorrowed {
    x: &amp;i32,
    y: &amp;i32,
}

#[derive(Debug)]
enum Either {
    Num(i32),
    Ref(&amp;i32),
}

fn main() {
    let x = 18;
    let y = 15;

    let single = Borrowed(&amp;x);
    let double = NamedBorrowed { x: &amp;x, y: &amp;y };
    let reference = Either::Ref(&amp;x);
    let number    = Either::Num(y);

    println!("x is borrowed in {:?}", single);
    println!("x and y are borrowed in {:?}", double);
    println!("x is borrowed in {:?}", reference);
    println!("y is *not* borrowed in {:?}", number);
}</code></pre></pre>
<ol start="7">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">/* 让代码工作 */

#[derive(Debug)]
struct NoCopyType {}

#[derive(Debug)]
struct Example&lt;'a, 'b&gt; {
    a: &amp;'a u32,
    b: &amp;'b NoCopyType
}

fn main()
{ 
  let var_a = 35;
  let example: Example;
  
  {
    let var_b = NoCopyType {};
    
    /* 修复错误 */
    example = Example { a: &amp;var_a, b: &amp;var_b };
  }
  
  println!("(Success!) {:?}", example);
}</code></pre></pre>
<ol start="8">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
#[derive(Debug)]
struct NoCopyType {}

#[derive(Debug)]
#[allow(dead_code)]
struct Example&lt;'a, 'b&gt; {
    a: &amp;'a u32,
    b: &amp;'b NoCopyType
}

/* 修复函数的签名 */
fn fix_me(foo: &amp;Example) -&gt; &amp;NoCopyType
{ foo.b }

fn main()
{
    let no_copy = NoCopyType {};
    let example = Example { a: &amp;1, b: &amp;no_copy };
    fix_me(&amp;example);
    println!("Success!")
}</code></pre></pre>
<h2 id="方法-1"><a class="header" href="#方法-1">方法</a></h2>
<p>方法的生命周期标注跟函数类似。</p>
<p><strong>示例</strong></p>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Owner(i32);

impl Owner {
    fn add_one&lt;'a&gt;(&amp;'a mut self) { self.0 += 1; }
    fn print&lt;'a&gt;(&amp;'a self) {
        println!("`print`: {}", self.0);
    }
}

fn main() {
    let mut owner = Owner(18);

    owner.add_one();
    owner.print();
}</code></pre></pre>
<ol start="9">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">/* 添加合适的生命周期让下面代码工作 */
struct ImportantExcerpt {
    part: &amp;str,
}

impl ImportantExcerpt {
    fn level(&amp;'a self) -&gt; i32 {
        3
    }
}

fn main() {}</code></pre></pre>
<h2 id="生命周期消除-elision-"><a class="header" href="#生命周期消除-elision-">生命周期消除( Elision )</a></h2>
<p>有一些生命周期的标注方式很常见，因此编译器提供了一些规则，可以让我们在一些场景下无需去标注生命周期，既节省了敲击键盘的繁琐，又能提升可读性。</p>
<p>这种规则被称为生命周期消除规则( Elision )，该规则之所以存在，仅仅是因为这些场景太通用了，为了方便用户而已。事实上对于借用检查器而言，该有的生命周期一个都不能少，只不过对于用户而言，可以省去一些。</p>
<ol start="10">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">/* 移除所有可以消除的生命周期标注 */

fn nput&lt;'a&gt;(x: &amp;'a i32) {
    println!("`annotated_input`: {}", x);
}

fn pass&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32 { x }

fn longest&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;'a str {
    x
}

struct Owner(i32);

impl Owner {
    fn add_one&lt;'a&gt;(&amp;'a mut self) { self.0 += 1; }
    fn print&lt;'a&gt;(&amp;'a self) {
        println!("`print`: {}", self.0);
    }
}

struct Person&lt;'a&gt; {
    age: u8,
    name: &amp;'a str,
}

enum Either&lt;'a&gt; {
    Num(i32),
    Ref(&amp;'a i32),
}

fn main() {}</code></pre></pre>
<blockquote>
<p>你可以在<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/lifetime/basic.md">这里</a>找到答案(在 solutions 路径下)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="static-and-t-static"><a class="header" href="#static-and-t-static">&amp;'static and T: 'static</a></h1>
<p><code>'static</code> 是一个 Rust 保留的生命周期名称，在之前我们可能已经见过好几次了:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 引用的生命周期是 'static :
let s: &amp;'static str = "hello world";

// 'static 也可以用于特征约束中:
fn generic&lt;T&gt;(x: T) where T: 'static {}
<span class="boring">}</span></code></pre></pre>
<p>虽然它们都是 <code>'static</code>，但是也稍有不同。</p>
<h2 id="static"><a class="header" href="#static">&amp;'static</a></h2>
<p>作为一个引用生命周期，<code>&amp;'static</code> 说明该引用指向的数据可以跟程序活得一样久，但是该引用的生命周期依然有可能被强转为一个更短的生命周期。</p>
<ol>
<li>🌟🌟 有好几种方法可以将一个变量标记为  <code>'static</code> 生命周期, 其中两种都是和保存在二进制文件中相关( 例如字符串字面量就是保存在二进制文件中，它的生命周期是 <code>'static</code> )。</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
/* 使用两种方法填空 */
fn main() {
    __;
    need_static(v);

    println!("Success!")
}

fn need_static(r : &amp;'static str) {
    assert_eq!(r, "hello");
}</code></pre></pre>
<ol start="2">
<li>🌟🌟🌟🌟 使用 <code>Box::leak</code> 也可以产生 <code>'static</code> 生命周期</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct Config {
    a: String,
    b: String,
}
static mut config: Option&lt;&amp;mut Config&gt; = None;

/* 让代码工作，但不要修改函数的签名 */
fn init() -&gt; Option&lt;&amp;'static mut Config&gt; {
    Some(&amp;mut Config {
        a: "A".to_string(),
        b: "B".to_string(),
    })
}


fn main() {
    unsafe {
        config = init();

        println!("{:?}",config)
    }
}</code></pre></pre>
<ol start="3">
<li>🌟 <code>&amp;'static</code> 只能说明引用指向的数据是能一直存活的，但是引用本身依然受限于它的作用域</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    {
        // 字符串字面量能跟程序活得一样久，因此 `static_string` 的生命周期是 `'static`
        let static_string = "I'm in read-only memory";
        println!("static_string: {}", static_string);

        // 当 `static_string` 超出作用域时，该引用就无法再被使用，但是引用指向的数据( 字符串字面量 ) 依然保存在二进制 binary 所占用的内存中
    }

    println!("static_string reference remains alive: {}", static_string);
}</code></pre></pre>
<ol start="4">
<li><code>&amp;'static</code> 可以被强转成一个较短的生命周期</li>
</ol>
<p><strong>Example</strong></p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// 声明一个 static 常量，它拥有 `'static` 生命周期.
static NUM: i32 = 18;

// 返回常量 `Num` 的引用，注意，这里的生命周期从 `'static` 强转为 `'a`
fn coerce_static&lt;'a&gt;(_: &amp;'a i32) -&gt; &amp;'a i32 {
    &amp;NUM
}

fn main() {
    {
        let lifetime_num = 9;

        let coerced_static = coerce_static(&amp;lifetime_num);

        println!("coerced_static: {}", coerced_static);
    }

    println!("NUM: {} stays accessible!", NUM);
}</code></pre></pre>
<h2 id="t-static"><a class="header" href="#t-static">T: 'static</a></h2>
<p>关于 <code>'static</code> 的特征约束详细解释，请参见 <a href="https://course.rs/advance/lifetime/static.html#t-static">Rust 语言圣经</a>，这里就不再赘述。</p>
<ol start="5">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">/* 让代码工作 */
use std::fmt::Debug;

fn print_it&lt;T: Debug + 'static&gt;( input: T) {
    println!( "'static value passed in is: {:?}", input );
}

fn print_it1( input: impl Debug + 'static ) {
    println!( "'static value passed in is: {:?}", input );
}


fn print_it2&lt;T: Debug + 'static&gt;( input: &amp;T) {
    println!( "'static value passed in is: {:?}", input );
}

fn main() {
    // i 是有所有权的数据，并没有包含任何引用，因此它是 'static
    let i = 5;
    print_it(i);

    // 但是 &amp;i 是一个引用，生命周期受限于作用域，因此它不是 'static
    print_it(&amp;i);

    print_it1(&amp;i);

    // 但是下面的代码可以正常运行 !
    print_it2(&amp;i);
}</code></pre></pre>
<ol start="6">
<li>🌟🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::fmt::Display;

fn main() {
  let mut string = "First".to_owned();

  string.push_str(string.to_uppercase().as_str());
  print_a(&amp;string);
  print_b(&amp;string);
  print_c(&amp;string); // Compilation error
  print_d(&amp;string); // Compilation error
  print_e(&amp;string);
  print_f(&amp;string);
  print_g(&amp;string); // Compilation error
}

fn print_a&lt;T: Display + 'static&gt;(t: &amp;T) {
  println!("{}", t);
}

fn print_b&lt;T&gt;(t: &amp;T)
where
  T: Display + 'static,
{
  println!("{}", t);
}

fn print_c(t: &amp;'static dyn Display) {
  println!("{}", t)
}

fn print_d(t: &amp;'static impl Display) {
  println!("{}", t)
}

fn print_e(t: &amp;(dyn Display + 'static)) {
  println!("{}", t)
}

fn print_f(t: &amp;(impl Display + 'static)) {
  println!("{}", t)
}

fn print_g(t: &amp;'static String) {
  println!("{}", t);
}</code></pre></pre>
<blockquote>
<p>你可以在<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/lifetime/static.md">这里</a>找到答案(在 solutions 路径下)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="深入生命周期"><a class="header" href="#深入生命周期">深入生命周期</a></h1>
<h2 id="特征约束-1"><a class="header" href="#特征约束-1">特征约束</a></h2>
<p>就像泛型类型可以有约束一样，生命周期也可以有约束 ，如下所示：</p>
<ul>
<li><code>T: 'a</code>，所有引用在 <code>T</code> 必须超过生命周期 <code>'a</code></li>
<li><code>T: Trait + 'a</code>: <code>T</code> 必须实现特征 <code>Trait</code> 并且所有引用在 <code>T</code> 必须超过生命周期 <code>'a</code></li>
</ul>
<p><strong>示例</strong></p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::fmt::Debug; // 特征约束使用

#[derive(Debug)]
struct Ref&lt;'a, T: 'a&gt;(&amp;'a T);
// `Ref` 包含对泛型类型 `T` 的引用，该泛型类型具有
// 未知的生命周期 `'a`. `T` 是约定任何
// 引用在 `T` 必须大于 `'a` 。此外，在生命周期
// 里 `Ref` 不能超过 `'a`。

// 使用 `Debug` 特征打印的通用函数。
fn print&lt;T&gt;(t: T) where
    T: Debug {
    println!("`print`: t is {:?}", t);
}

// 这里引用 `T` 使用 where `T` 实现
// `Debug` 和所有引用 `T` 都要比 `'a` 长
// 此外，`'a`必须要比函数声明周期长
fn print_ref&lt;'a, T&gt;(t: &amp;'a T) where
    T: Debug + 'a {
    println!("`print_ref`: t is {:?}", t);
}

fn main() {
    let x = 7;
    let ref_x = Ref(&amp;x);

    print_ref(&amp;ref_x);
    print(ref_x);
}</code></pre></pre>
<ol>
<li>🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">/* 使用生命周期注释结构体
1. `r` 和 `s` 必须是不同生命周期
2. `s` 的生命周期需要大于 'r'
*/
struct DoubleRef&lt;T&gt; {
    r: &amp;T,
    s: &amp;T
}
fn main() {
    println!("Success!")
}</code></pre></pre>
<ol start="2">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">/* 添加类型约束使下面代码正常运行 */
struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

impl&lt;'a, 'b&gt; ImportantExcerpt&lt;'a&gt; {
    fn announce_and_return_part(&amp;'a self, announcement: &amp;'b str) -&gt; &amp;'b str {
        println!("Attention please: {}", announcement);
        self.part
    }
}

fn main() {
    println!("Success!")
}</code></pre></pre>
<ol start="3">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">/* 添加类型约束使下面代码正常运行 */
fn f&lt;'a, 'b&gt;(x: &amp;'a i32, mut y: &amp;'b i32) {
    y = x;                      
    let r: &amp;'b &amp;'a i32 = &amp;&amp;0;   
}

fn main() {
    println!("Success!")
}</code></pre></pre>
<h2 id="hrtb更高等级特征约束higher-ranked-trait-bounds"><a class="header" href="#hrtb更高等级特征约束higher-ranked-trait-bounds">HRTB（更高等级特征约束）(Higher-ranked trait bounds)</a></h2>
<p>类型约束可能在生命周期中排名更高。这些约束指定了一个约束对于所有生命周期都为真。例如，诸如此类的约束 <code>for&lt;'a&gt; &amp;'a T: PartialEq&lt;i32&gt;</code> 需要如下实现：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a&gt; PartialEq&lt;i32&gt; for &amp;'a T {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>然后可以用于将一个 <code>&amp;'a T</code> 与任何生命周期进行比较 <code>i32</code> 。</p>
<p>这里只能使用更高级别的约束，因为引用的生命周期比函数上任何可能的生命周期参数都短。</p>
<ol start="4">
<li>🌟🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2021">/* 添加 HRTB 使下面代码正常运行！ */
fn call_on_ref_zero&lt;'a, F&gt;(f: F) where F: Fn(&amp;'a i32) {
    let zero = 0;
    f(&amp;zero);
}

fn main() {
    println!("Success!")
}</code></pre></pre>
<h2 id="nll非词汇生命周期non-lexical-lifetime"><a class="header" href="#nll非词汇生命周期non-lexical-lifetime">NLL（非词汇生命周期）(Non-Lexical Lifetime)</a></h2>
<p>在解释 NLL 之前，我们先看一段代码：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
   let mut s = String::from("hello");

    let r1 = &amp;s;
    let r2 = &amp;s;
    println!("{} and {}", r1, r2);

    let r3 = &amp;mut s;
    println!("{}", r3);
}</code></pre></pre>
<p>根据我们目前的知识，这段代码会因为违反 Rust 中的借用规则而导致错误。</p>
<p>但是，如果您执行 <code>cargo run</code> ，那么一切都没问题，那么这里发生了什么？</p>
<p>编译器在作用域结束之前判断不再使用引用的能力称为 <strong>非词法生命周期</strong>（简称 <strong>NLL</strong> ）。</p>
<p>有了这种能力，编译器就知道最后一次使用引用是什么时候，并根据这些知识优化借用规则。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut u = 0i32;
let mut v = 1i32;
let mut w = 2i32;

// lifetime of `a` = α ∪ β ∪ γ
let mut a = &amp;mut u;     // --+ α. lifetime of `&amp;mut u`  --+ lexical "lifetime" of `&amp;mut u`,`&amp;mut u`, `&amp;mut w` and `a`
use(a);                 //   |                            |
*a = 3; // &lt;-----------------+                            |
...                     //                                |
a = &amp;mut v;             // --+ β. lifetime of `&amp;mut v`    |
use(a);                 //   |                            |
*a = 4; // &lt;-----------------+                            |
...                     //                                |
a = &amp;mut w;             // --+ γ. lifetime of `&amp;mut w`    |
use(a);                 //   |                            |
*a = 5; // &lt;-----------------+ &lt;--------------------------+
<span class="boring">}</span></code></pre></pre>
<h2 id="再借用"><a class="header" href="#再借用">再借用</a></h2>
<p>学习了 NLL 之后，我们现在可以很容易地理解再借用了。</p>
<p><strong>示例</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021">#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

impl Point {
    fn move_to(&amp;mut self, x: i32, y: i32) {
        self.x = x;
        self.y = y;
    }
}

fn main() {
    let mut p = Point { x: 0, y: 0 };
    let r = &amp;mut p;
    // 这里是再借用
    let rr: &amp;Point = &amp;*r;

    println!("{:?}", rr); // 这里结束再借用

    // 再借用结束，现在我们可以继续使用 `r`
    r.move_to(10, 10);
    println!("{:?}", r);
}</code></pre></pre>
<ol start="5">
<li>🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">/* 通过重新排序一些代码使下面代码正常运行 */
fn main() {
    let mut data = 10;
    let ref1 = &amp;mut data;
    let ref2 = &amp;mut *ref1;

    *ref1 += 1;
    *ref2 += 2;

    println!("{}", data);
}</code></pre></pre>
<h2 id="未约束的生命周期"><a class="header" href="#未约束的生命周期">未约束的生命周期</a></h2>
<p>在 <a href="https://doc.rust-lang.org/nomicon/unbounded-lifetimes.html">Nomicon - Unbounded Lifetimes</a> 中查看更多信息。</p>
<h2 id="更多省略规则"><a class="header" href="#更多省略规则">更多省略规则</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a&gt; Reader for BufReader&lt;'a&gt; {
    // 'a 在以下方法中不使用
}

// 可以写为：
impl Reader for BufReader&lt;'_&gt; {
    
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust 2015
struct Ref&lt;'a, T: 'a&gt; {
    field: &amp;'a T
}

// Rust 2018
struct Ref&lt;'a, T&gt; {
    field: &amp;'a T
}
<span class="boring">}</span></code></pre></pre>
<h2 id="艰难的练习"><a class="header" href="#艰难的练习">艰难的练习</a></h2>
<ol start="6">
<li>🌟🌟🌟🌟</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2021">/* 使下面代码正常运行 */
struct Interface&lt;'a&gt; {
    manager: &amp;'a mut Manager&lt;'a&gt;
}

impl&lt;'a&gt; Interface&lt;'a&gt; {
    pub fn noop(self) {
        println!("interface consumed");
    }
}

struct Manager&lt;'a&gt; {
    text: &amp;'a str
}

struct List&lt;'a&gt; {
    manager: Manager&lt;'a&gt;,
}

impl&lt;'a&gt; List&lt;'a&gt; {
    pub fn get_interface(&amp;'a mut self) -&gt; Interface {
        Interface {
            manager: &amp;mut self.manager
        }
    }
}

fn main() {
    let mut list = List {
        manager: Manager {
            text: "hello"
        }
    };

    list.get_interface().noop();

    println!("Interface should be dropped here and the borrow released");

    use_list(&amp;list);
}

fn use_list(list: &amp;List) {
    println!("{}", list.manager.text);
}</code></pre></pre>
<blockquote>
<p>你可以在<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/lifetime/advance.md">这里</a>找到答案(在 solutions 路径下)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functional-programing"><a class="header" href="#functional-programing">Functional programing</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="closure"><a class="header" href="#closure">Closure</a></h1>
<p>下面代码是Rust圣经课程中<a href="http://course.rs/advance/functional-programing/closure.html#%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85">闭包</a>章节的课内练习题答案：</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Cacher&lt;T,E&gt;
where
    T: Fn(E) -&gt; E,
    E: Copy
{
    query: T,
    value: Option&lt;E&gt;,
}

impl&lt;T,E&gt; Cacher&lt;T,E&gt;
where
    T: Fn(E) -&gt; E,
    E: Copy
{
    fn new(query: T) -&gt; Cacher&lt;T,E&gt; {
        Cacher {
            query,
            value: None,
        }
    }

    fn value(&amp;mut self, arg: E) -&gt; E {
        match self.value {
            Some(v) =&gt; v,
            None =&gt; {
                let v = (self.query)(arg);
                self.value = Some(v);
                v
            }
        }
    }
}
fn main() {
  
}

#[test]
fn call_with_different_values() {
    let mut c = Cacher::new(|a| a);

    let v1 = c.value(1);
    let v2 = c.value(2);

    assert_eq!(v2, 1);
}</code></pre></pre>
<blockquote>
<p>你可以在<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/functional-programing/closure.md">这里</a>找到答案(在 solutions 路径下)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterator"><a class="header" href="#iterator">Iterator</a></h1>
<blockquote>
<p>你可以在<a href="https://github.com/sunface/rust-by-practice/blob/master/solutions/functional-programing/iterator.md">这里</a>找到答案(在 solutions 路径下)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="newtype-and-sized"><a class="header" href="#newtype-and-sized">newtype and Sized</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="smart-pointers"><a class="header" href="#smart-pointers">Smart pointers</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="box"><a class="header" href="#box">Box</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deref"><a class="header" href="#deref">Deref</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="drop"><a class="header" href="#drop">Drop</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rc-and-arc"><a class="header" href="#rc-and-arc">Rc and Arc</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cell-and-refcell"><a class="header" href="#cell-and-refcell">Cell and RefCell</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="weak-and-circle-reference"><a class="header" href="#weak-and-circle-reference">Weak and Circle reference</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="self-referential"><a class="header" href="#self-referential">Self referential</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="threads"><a class="header" href="#threads">Threads</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-using"><a class="header" href="#basic-using">Basic using</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="message-passing"><a class="header" href="#message-passing">Message passing</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sync"><a class="header" href="#sync">Sync</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="atomic"><a class="header" href="#atomic">Atomic</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="send-and-sync"><a class="header" href="#send-and-sync">Send and Sync</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="global-variables"><a class="header" href="#global-variables">Global variables</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="errors"><a class="header" href="#errors">Errors</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unsafe-doing"><a class="header" href="#unsafe-doing">Unsafe doing</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="内联汇编"><a class="header" href="#内联汇编">内联汇编</a></h1>
<p>Rust provides support for inline assembly via the <code>asm!</code> macro.
It can be used to embed handwritten assembly in the assembly output generated by the compiler.
Generally this should not be necessary, but might be where the required performance or timing
cannot be otherwise achieved. Accessing low level hardware primitives, e.g. in kernel code, may also demand this functionality.</p>
<blockquote>
<p><strong>Note</strong>: the examples here are given in x86/x86-64 assembly, but other architectures are also supported.</p>
</blockquote>
<p>Inline assembly is currently supported on the following architectures:</p>
<ul>
<li>x86 and x86-64</li>
<li>ARM</li>
<li>AArch64</li>
<li>RISC-V</li>
</ul>
<h2 id="basic-usage"><a class="header" href="#basic-usage">Basic usage</a></h2>
<p>Let us start with the simplest possible example:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

unsafe {
    asm!("nop");
}
<span class="boring">}</span></code></pre></pre>
<p>This will insert a NOP (no operation) instruction into the assembly generated by the compiler.
Note that all <code>asm!</code> invocations have to be inside an <code>unsafe</code> block, as they could insert
arbitrary instructions and break various invariants. The instructions to be inserted are listed
in the first argument of the <code>asm!</code> macro as a string literal.</p>
<h2 id="inputs-and-outputs"><a class="header" href="#inputs-and-outputs">Inputs and outputs</a></h2>
<p>Now inserting an instruction that does nothing is rather boring. Let us do something that
actually acts on data:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

let x: u64;
unsafe {
    asm!("mov {}, 5", out(reg) x);
}
assert_eq!(x, 5);
<span class="boring">}</span></code></pre></pre>
<p>This will write the value <code>5</code> into the <code>u64</code> variable <code>x</code>.
You can see that the string literal we use to specify instructions is actually a template string.
It is governed by the same rules as Rust <a href="https://doc.rust-lang.org/std/fmt/#syntax">format strings</a>.
The arguments that are inserted into the template however look a bit different than you may
be familiar with. First we need to specify if the variable is an input or an output of the
inline assembly. In this case it is an output. We declared this by writing <code>out</code>.
We also need to specify in what kind of register the assembly expects the variable.
In this case we put it in an arbitrary general purpose register by specifying <code>reg</code>.
The compiler will choose an appropriate register to insert into
the template and will read the variable from there after the inline assembly finishes executing.</p>
<p>Let us see another example that also uses an input:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

let i: u64 = 3;
let o: u64;
unsafe {
    asm!(
        "mov {0}, {1}",
        "add {0}, 5",
        out(reg) o,
        in(reg) i,
    );
}
assert_eq!(o, 8);
<span class="boring">}</span></code></pre></pre>
<p>This will add <code>5</code> to the input in variable <code>i</code> and write the result to variable <code>o</code>.
The particular way this assembly does this is first copying the value from <code>i</code> to the output,
and then adding <code>5</code> to it.</p>
<p>The example shows a few things:</p>
<p>First, we can see that <code>asm!</code> allows multiple template string arguments; each
one is treated as a separate line of assembly code, as if they were all joined
together with newlines between them. This makes it easy to format assembly
code.</p>
<p>Second, we can see that inputs are declared by writing <code>in</code> instead of <code>out</code>.</p>
<p>Third, we can see that we can specify an argument number, or name as in any format string.
For inline assembly templates this is particularly useful as arguments are often used more than once.
For more complex inline assembly using this facility is generally recommended, as it improves
readability, and allows reordering instructions without changing the argument order.</p>
<p>We can further refine the above example to avoid the <code>mov</code> instruction:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

let mut x: u64 = 3;
unsafe {
    asm!("add {0}, 5", inout(reg) x);
}
assert_eq!(x, 8);
<span class="boring">}</span></code></pre></pre>
<p>We can see that <code>inout</code> is used to specify an argument that is both input and output.
This is different from specifying an input and output separately in that it is guaranteed to assign both to the same register.</p>
<p>It is also possible to specify different variables for the input and output parts of an <code>inout</code> operand:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

let x: u64 = 3;
let y: u64;
unsafe {
    asm!("add {0}, 5", inout(reg) x =&gt; y);
}
assert_eq!(y, 8);
<span class="boring">}</span></code></pre></pre>
<h2 id="late-output-operands"><a class="header" href="#late-output-operands">Late output operands</a></h2>
<p>The Rust compiler is conservative with its allocation of operands. It is assumed that an <code>out</code>
can be written at any time, and can therefore not share its location with any other argument.
However, to guarantee optimal performance it is important to use as few registers as possible,
so they won't have to be saved and reloaded around the inline assembly block.
To achieve this Rust provides a <code>lateout</code> specifier. This can be used on any output that is
written only after all inputs have been consumed.
There is also a <code>inlateout</code> variant of this specifier.</p>
<p>Here is an example where <code>inlateout</code> <em>cannot</em> be used:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

let mut a: u64 = 4;
let b: u64 = 4;
let c: u64 = 4;
unsafe {
    asm!(
        "add {0}, {1}",
        "add {0}, {2}",
        inout(reg) a,
        in(reg) b,
        in(reg) c,
    );
}
assert_eq!(a, 12);
<span class="boring">}</span></code></pre></pre>
<p>Here the compiler is free to allocate the same register for inputs <code>b</code> and <code>c</code> since it knows they have the same value. However it must allocate a separate register for <code>a</code> since it uses <code>inout</code> and not <code>inlateout</code>. If <code>inlateout</code> was used, then <code>a</code> and <code>c</code> could be allocated to the same register, in which case the first instruction to overwrite the value of <code>c</code> and cause the assembly code to produce the wrong result.</p>
<p>However the following example can use <code>inlateout</code> since the output is only modified after all input registers have been read:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

let mut a: u64 = 4;
let b: u64 = 4;
unsafe {
    asm!("add {0}, {1}", inlateout(reg) a, in(reg) b);
}
assert_eq!(a, 8);
<span class="boring">}</span></code></pre></pre>
<p>As you can see, this assembly fragment will still work correctly if <code>a</code> and <code>b</code> are assigned to the same register.</p>
<h2 id="explicit-register-operands"><a class="header" href="#explicit-register-operands">Explicit register operands</a></h2>
<p>Some instructions require that the operands be in a specific register.
Therefore, Rust inline assembly provides some more specific constraint specifiers.
While <code>reg</code> is generally available on any architecture, explicit registers are highly architecture specific. E.g. for x86 the general purpose registers <code>eax</code>, <code>ebx</code>, <code>ecx</code>, <code>edx</code>, <code>ebp</code>, <code>esi</code>, and <code>edi</code> among others can be addressed by their name.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

let cmd = 0xd1;
unsafe {
    asm!("out 0x64, eax", in("eax") cmd);
}
<span class="boring">}</span></code></pre></pre>
<p>In this example we call the <code>out</code> instruction to output the content of the <code>cmd</code> variable to port <code>0x64</code>. Since the <code>out</code> instruction only accepts <code>eax</code> (and its sub registers) as operand we had to use the <code>eax</code> constraint specifier.</p>
<blockquote>
<p><strong>Note</strong>: unlike other operand types, explicit register operands cannot be used in the template string: you can't use <code>{}</code> and should write the register name directly instead. Also, they must appear at the end of the operand list after all other operand types.</p>
</blockquote>
<p>Consider this example which uses the x86 <code>mul</code> instruction:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

fn mul(a: u64, b: u64) -&gt; u128 {
    let lo: u64;
    let hi: u64;

    unsafe {
        asm!(
            // The x86 mul instruction takes rax as an implicit input and writes
            // the 128-bit result of the multiplication to rax:rdx.
            "mul {}",
            in(reg) a,
            inlateout("rax") b =&gt; lo,
            lateout("rdx") hi
        );
    }

    ((hi as u128) &lt;&lt; 64) + lo as u128
}
<span class="boring">}</span></code></pre></pre>
<p>This uses the <code>mul</code> instruction to multiply two 64-bit inputs with a 128-bit result.
The only explicit operand is a register, that we fill from the variable <code>a</code>.
The second operand is implicit, and must be the <code>rax</code> register, which we fill from the variable <code>b</code>.
The lower 64 bits of the result are stored in <code>rax</code> from which we fill the variable <code>lo</code>.
The higher 64 bits are stored in <code>rdx</code> from which we fill the variable <code>hi</code>.</p>
<h2 id="clobbered-registers"><a class="header" href="#clobbered-registers">Clobbered registers</a></h2>
<p>In many cases inline assembly will modify state that is not needed as an output.
Usually this is either because we have to use a scratch register in the assembly or because instructions modify state that we don't need to further examine.
This state is generally referred to as being "clobbered".
We need to tell the compiler about this since it may need to save and restore this state around the inline assembly block.</p>
<pre><pre class="playground"><code class="language-rust edition2021">use core::arch::asm;

fn main() {
    // three entries of four bytes each
    let mut name_buf = [0_u8; 12];
    // String is stored as ascii in ebx, edx, ecx in order
    // Because ebx is reserved, we get a scratch register and move from
    // ebx into it in the asm.  The asm needs to preserve the value of
    // that register though, so it is pushed and popped around the main asm
    // (in 64 bit mode for 64 bit processors, 32 bit processors would use ebx)

    unsafe {
        asm!(
            "push rbx",
            "cpuid",
            "mov [{0}], ebx",
            "mov [{0} + 4], edx",
            "mov [{0} + 8], ecx",
            "pop rbx",
            // We use a pointer to an array for storing the values to simplify
            // the Rust code at the cost of a couple more asm instructions
            // This is more explicit with how the asm works however, as opposed
            // to explicit register outputs such as `out("ecx") val`
            // The *pointer itself* is only an input even though it's written behind
            in(reg) name_buf.as_mut_ptr(),
            // select cpuid 0, also specify eax as clobbered
            inout("eax") 0 =&gt; _,
            // cpuid clobbers these registers too
            out("ecx") _,
            out("edx") _,
        );
    }

    let name = core::str::from_utf8(&amp;name_buf).unwrap();
    println!("CPU Manufacturer ID: {}", name);
}</code></pre></pre>
<p>In the example above we use the <code>cpuid</code> instruction to read the CPU manufacturer ID.
This instruction writes to <code>eax</code> with the maximum supported <code>cpuid</code> argument and <code>ebx</code>, <code>esx</code>, and <code>ecx</code> with the CPU manufacturer ID as ASCII bytes in that order.</p>
<p>Even though <code>eax</code> is never read we still need to tell the compiler that the register has been modified so that the compiler can save any values that were in these registers before the asm. This is done by declaring it as an output but with <code>_</code> instead of a variable name, which indicates that the output value is to be discarded.</p>
<p>This code also works around the limitation that <code>ebx</code> is a reserved register by LLVM. That means that LLVM assumes that it has full control over the register and it must be restored to its original state before exiting the asm block, so it cannot be used as an output. To work around this we save the register via <code>push</code>, read from <code>ebx</code> inside the asm block into a temporary register allocated with <code>out(reg)</code> and then restoring <code>ebx</code> to its original state via <code>pop</code>. The <code>push</code> and <code>pop</code> use the full 64-bit <code>rbx</code> version of the register to ensure that the entire register is saved. On 32 bit targets the code would instead use <code>ebx</code> in the <code>push</code>/<code>pop</code>.</p>
<p>This can also be used with a general register class (e.g. <code>reg</code>) to obtain a scratch register for use inside the asm code:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

// Multiply x by 6 using shifts and adds
let mut x: u64 = 4;
unsafe {
    asm!(
        "mov {tmp}, {x}",
        "shl {tmp}, 1",
        "shl {x}, 2",
        "add {x}, {tmp}",
        x = inout(reg) x,
        tmp = out(reg) _,
    );
}
assert_eq!(x, 4 * 6);
<span class="boring">}</span></code></pre></pre>
<h2 id="symbol-operands-and-abi-clobbers"><a class="header" href="#symbol-operands-and-abi-clobbers">Symbol operands and ABI clobbers</a></h2>
<p>By default, <code>asm!</code> assumes that any register not specified as an output will have its contents preserved by the assembly code. The <a href="unsafe/../../reference/inline-assembly.html#abi-clobbers"><code>clobber_abi</code></a> argument to <code>asm!</code> tells the compiler to automatically insert the necessary clobber operands according to the given calling convention ABI: any register which is not fully preserved in that ABI will be treated as clobbered.  Multiple <code>clobber_abi</code> arguments may be provided and all clobbers from all specified ABIs will be inserted.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

extern "C" fn foo(arg: i32) -&gt; i32 {
    println!("arg = {}", arg);
    arg * 2
}

fn call_foo(arg: i32) -&gt; i32 {
    unsafe {
        let result;
        asm!(
            "call *{}",
            // Function pointer to call
            in(reg) foo,
            // 1st argument in rdi
            in("rdi") arg,
            // Return value in rax
            out("rax") result,
            // Mark all registers which are not preserved by the "C" calling
            // convention as clobbered.
            clobber_abi("C"),
        );
        result
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="register-template-modifiers"><a class="header" href="#register-template-modifiers">Register template modifiers</a></h2>
<p>In some cases, fine control is needed over the way a register name is formatted when inserted into the template string. This is needed when an architecture's assembly language has several names for the same register, each typically being a "view" over a subset of the register (e.g. the low 32 bits of a 64-bit register).</p>
<p>By default the compiler will always choose the name that refers to the full register size (e.g. <code>rax</code> on x86-64, <code>eax</code> on x86, etc).</p>
<p>This default can be overridden by using modifiers on the template string operands, just like you would with format strings:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

let mut x: u16 = 0xab;

unsafe {
    asm!("mov {0:h}, {0:l}", inout(reg_abcd) x);
}

assert_eq!(x, 0xabab);
<span class="boring">}</span></code></pre></pre>
<p>In this example, we use the <code>reg_abcd</code> register class to restrict the register allocator to the 4 legacy x86 registers (<code>ax</code>, <code>bx</code>, <code>cx</code>, <code>dx</code>) of which the first two bytes can be addressed independently.</p>
<p>Let us assume that the register allocator has chosen to allocate <code>x</code> in the <code>ax</code> register.
The <code>h</code> modifier will emit the register name for the high byte of that register and the <code>l</code> modifier will emit the register name for the low byte. The asm code will therefore be expanded as <code>mov ah, al</code> which copies the low byte of the value into the high byte.</p>
<p>If you use a smaller data type (e.g. <code>u16</code>) with an operand and forget the use template modifiers, the compiler will emit a warning and suggest the correct modifier to use.</p>
<h2 id="memory-address-operands"><a class="header" href="#memory-address-operands">Memory address operands</a></h2>
<p>Sometimes assembly instructions require operands passed via memory addresses/memory locations.
You have to manually use the memory address syntax specified by the target architecture.
For example, on x86/x86_64 using Intel assembly syntax, you should wrap inputs/outputs in <code>[]</code> to indicate they are memory operands:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

fn load_fpu_control_word(control: u16) {
    unsafe {
        asm!("fldcw [{}]", in(reg) &amp;control, options(nostack));
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="labels"><a class="header" href="#labels">Labels</a></h2>
<p>Any reuse of a named label, local or otherwise, can result in an assembler or linker error or may cause other strange behavior. Reuse of a named label can happen in a variety of ways including:</p>
<ul>
<li>explicitly: using a label more than once in one <code>asm!</code> block, or multiple times across blocks.</li>
<li>implicitly via inlining: the compiler is allowed to instantiate multiple copies of an <code>asm!</code> block, for example when the function containing it is inlined in multiple places.</li>
<li>implicitly via LTO: LTO can cause code from <em>other crates</em> to be placed in the same codegen unit, and so could bring in arbitrary labels.</li>
</ul>
<p>As a consequence, you should only use GNU assembler <strong>numeric</strong> <a href="https://sourceware.org/binutils/docs/as/Symbol-Names.html#Local-Labels">local labels</a> inside inline assembly code. Defining symbols in assembly code may lead to assembler and/or linker errors due to duplicate symbol definitions.</p>
<p>Moreover, on x86 when using the default Intel syntax, due to <a href="https://bugs.llvm.org/show_bug.cgi?id=36144">an LLVM bug</a>, you shouldn't use labels exclusively made of <code>0</code> and <code>1</code> digits, e.g. <code>0</code>, <code>11</code> or <code>101010</code>, as they may end up being interpreted as binary values. Using <code>options(att_syntax)</code> will avoid any ambiguity, but that affects the syntax of the <em>entire</em> <code>asm!</code> block. (See <a href="unsafe/inline-asm.html#options">Options</a>, below, for more on <code>options</code>.)</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

let mut a = 0;
unsafe {
    asm!(
        "mov {0}, 10",
        "2:",
        "sub {0}, 1",
        "cmp {0}, 3",
        "jle 2f",
        "jmp 2b",
        "2:",
        "add {0}, 2",
        out(reg) a
    );
}
assert_eq!(a, 5);
<span class="boring">}</span></code></pre></pre>
<p>This will decrement the <code>{0}</code> register value from 10 to 3, then add 2 and store it in <code>a</code>.</p>
<p>This example shows a few things:</p>
<ul>
<li>First, that the same number can be used as a label multiple times in the same inline block.</li>
<li>Second, that when a numeric label is used as a reference (as an instruction operand, for example), the suffixes “b” (“backward”) or ”f” (“forward”) should be added to the numeric label. It will then refer to the nearest label defined by this number in this direction.</li>
</ul>
<h2 id="options"><a class="header" href="#options">Options</a></h2>
<p>By default, an inline assembly block is treated the same way as an external FFI function call with a custom calling convention: it may read/write memory, have observable side effects, etc. However, in many cases it is desirable to give the compiler more information about what the assembly code is actually doing so that it can optimize better.</p>
<p>Let's take our previous example of an <code>add</code> instruction:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

let mut a: u64 = 4;
let b: u64 = 4;
unsafe {
    asm!(
        "add {0}, {1}",
        inlateout(reg) a, in(reg) b,
        options(pure, nomem, nostack),
    );
}
assert_eq!(a, 8);
<span class="boring">}</span></code></pre></pre>
<p>Options can be provided as an optional final argument to the <code>asm!</code> macro. We specified three options here:</p>
<ul>
<li><code>pure</code> means that the asm code has no observable side effects and that its output depends only on its inputs. This allows the compiler optimizer to call the inline asm fewer times or even eliminate it entirely.</li>
<li><code>nomem</code> means that the asm code does not read or write to memory. By default the compiler will assume that inline assembly can read or write any memory address that is accessible to it (e.g. through a pointer passed as an operand, or a global).</li>
<li><code>nostack</code> means that the asm code does not push any data onto the stack. This allows the compiler to use optimizations such as the stack red zone on x86-64 to avoid stack pointer adjustments.</li>
</ul>
<p>These allow the compiler to better optimize code using <code>asm!</code>, for example by eliminating pure <code>asm!</code> blocks whose outputs are not needed.</p>
<p>See the <a href="unsafe/../../reference/inline-assembly.html">reference</a> for the full list of available options and their effects.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macro"><a class="header" href="#macro">macro</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tests"><a class="header" href="#tests">Tests</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="write-tests"><a class="header" href="#write-tests">Write Tests</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="benchmark"><a class="header" href="#benchmark">Benchmark</a></h1>
<p>https://doc.rust-lang.org/unstable-book/library-features/test.html</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unit-and-integration"><a class="header" href="#unit-and-integration">Unit and Integration</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assertions"><a class="header" href="#assertions">Assertions</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asyncawait"><a class="header" href="#asyncawait">Async/Await</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="async-and-await"><a class="header" href="#async-and-await">async and await!</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="future"><a class="header" href="#future">Future</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pin-and-unpin"><a class="header" href="#pin-and-unpin">Pin and Unpin</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stream"><a class="header" href="#stream">Stream</a></h1>

                        <div id="giscus-container"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <script type="text/javascript" charset="utf-8">
        var pagePath = "print.md"
        </script>


        <!-- Custom JS scripts -->
        <script src="assets/custom3.js"></script>
        <script src="assets/lang1.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>